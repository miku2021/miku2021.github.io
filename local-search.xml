<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>hashmap</title>
    <link href="/2020/07/11/hashmap/"/>
    <url>/2020/07/11/hashmap/</url>
    
    <content type="html"><![CDATA[<p>我们来分析jdk1.8中hashmap的源码</p><pre><code class="hljs java"><span class="hljs-comment">/*</span><span class="hljs-comment"> * Copyright (c) 1997, 2017, Oracle and/or its affiliates. All rights reserved.</span><span class="hljs-comment"> * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">package</span> java.util;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.io.InvalidObjectException;<span class="hljs-keyword">import</span> java.io.Serializable;<span class="hljs-keyword">import</span> java.lang.reflect.ParameterizedType;<span class="hljs-keyword">import</span> java.lang.reflect.Type;<span class="hljs-keyword">import</span> java.util.function.BiConsumer;<span class="hljs-keyword">import</span> java.util.function.BiFunction;<span class="hljs-keyword">import</span> java.util.function.Consumer;<span class="hljs-keyword">import</span> java.util.function.Function;<span class="hljs-keyword">import</span> sun.misc.SharedSecrets;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Hash table based implementation of the &lt;tt&gt;Map&lt;/tt&gt; interface.  This</span><span class="hljs-comment"> * implementation provides all of the optional map operations, and permits</span><span class="hljs-comment"> * &lt;tt&gt;null&lt;/tt&gt; values and the &lt;tt&gt;null&lt;/tt&gt; key.  (The &lt;tt&gt;HashMap&lt;/tt&gt;</span><span class="hljs-comment"> * class is roughly equivalent to &lt;tt&gt;Hashtable&lt;/tt&gt;, except that it is</span><span class="hljs-comment"> * unsynchronized and permits nulls.)  This class makes no guarantees as to</span><span class="hljs-comment"> * the order of the map; in particular, it does not guarantee that the order</span><span class="hljs-comment"> * will remain constant over time.</span><span class="hljs-comment"> *  </span><span class="hljs-comment">    hashmap允许key和value等于null</span><span class="hljs-comment">    hashmap和hashtable的区别在于，hashmap线程不安全并且允许null</span><span class="hljs-comment">    放入map的数据是无序的</span><span class="hljs-comment"></span><span class="hljs-comment"> * &lt;p&gt;This implementation provides constant-time performance for the basic</span><span class="hljs-comment"> * operations (&lt;tt&gt;get&lt;/tt&gt; and &lt;tt&gt;put&lt;/tt&gt;), assuming the hash function</span><span class="hljs-comment"> * disperses the elements properly among the buckets.  Iteration over</span><span class="hljs-comment"> * collection views requires time proportional to the "capacity" of the</span><span class="hljs-comment"> * &lt;tt&gt;HashMap&lt;/tt&gt; instance (the number of buckets) plus its size (the number</span><span class="hljs-comment"> * of key-value mappings).  Thus, it's very important not to set the initial</span><span class="hljs-comment"> * capacity too high (or the load factor too low) if iteration performance is</span><span class="hljs-comment"> * important.</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * &lt;p&gt;An instance of &lt;tt&gt;HashMap&lt;/tt&gt; has two parameters that affect its</span><span class="hljs-comment"> * performance: &lt;i&gt;initial capacity&lt;/i&gt; and &lt;i&gt;load factor&lt;/i&gt;.  The</span><span class="hljs-comment"> * &lt;i&gt;capacity&lt;/i&gt; is the number of buckets in the hash table, and the initial</span><span class="hljs-comment"> * capacity is simply the capacity at the time the hash table is created.  The</span><span class="hljs-comment"> * &lt;i&gt;load factor&lt;/i&gt; is a measure of how full the hash table is allowed to</span><span class="hljs-comment"> * get before its capacity is automatically increased.  When the number of</span><span class="hljs-comment"> * entries in the hash table exceeds the product of the load factor and the</span><span class="hljs-comment"> * current capacity, the hash table is &lt;i&gt;rehashed&lt;/i&gt; (that is, internal data</span><span class="hljs-comment"> * structures are rebuilt) so that the hash table has approximately twice the</span><span class="hljs-comment"> * number of buckets.</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * &lt;p&gt;As a general rule, the default load factor (.75) offers a good</span><span class="hljs-comment"> * tradeoff between time and space costs.  Higher values decrease the</span><span class="hljs-comment"> * space overhead but increase the lookup cost (reflected in most of</span><span class="hljs-comment"> * the operations of the &lt;tt&gt;HashMap&lt;/tt&gt; class, including</span><span class="hljs-comment"> * &lt;tt&gt;get&lt;/tt&gt; and &lt;tt&gt;put&lt;/tt&gt;).  The expected number of entries in</span><span class="hljs-comment"> * the map and its load factor should be taken into account when</span><span class="hljs-comment"> * setting its initial capacity, so as to minimize the number of</span><span class="hljs-comment"> * rehash operations.  If the initial capacity is greater than the</span><span class="hljs-comment"> * maximum number of entries divided by the load factor, no rehash</span><span class="hljs-comment"> * operations will ever occur.</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * &lt;p&gt;If many mappings are to be stored in a &lt;tt&gt;HashMap&lt;/tt&gt;</span><span class="hljs-comment"> * instance, creating it with a sufficiently large capacity will allow</span><span class="hljs-comment"> * the mappings to be stored more efficiently than letting it perform</span><span class="hljs-comment"> * automatic rehashing as needed to grow the table.  Note that using</span><span class="hljs-comment"> * many keys with the same &#123;<span class="hljs-doctag">@code</span> hashCode()&#125; is a sure way to slow</span><span class="hljs-comment"> * down performance of any hash table. To ameliorate impact, when keys</span><span class="hljs-comment"> * are &#123;<span class="hljs-doctag">@link</span> Comparable&#125;, this class may use comparison order among</span><span class="hljs-comment"> * keys to help break ties.</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * &lt;p&gt;&lt;strong&gt;Note that this implementation is not synchronized.&lt;/strong&gt;</span><span class="hljs-comment"> * If multiple threads access a hash map concurrently, and at least one of</span><span class="hljs-comment"> * the threads modifies the map structurally, it &lt;i&gt;must&lt;/i&gt; be</span><span class="hljs-comment"> * synchronized externally.  (A structural modification is any operation</span><span class="hljs-comment"> * that adds or deletes one or more mappings; merely changing the value</span><span class="hljs-comment"> * associated with a key that an instance already contains is not a</span><span class="hljs-comment"> * structural modification.)  This is typically accomplished by</span><span class="hljs-comment"> * synchronizing on some object that naturally encapsulates the map.</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * If no such object exists, the map should be "wrapped" using the</span><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> Collections#synchronizedMap Collections.synchronizedMap&#125;</span><span class="hljs-comment"> * method.  This is best done at creation time, to prevent accidental</span><span class="hljs-comment"> * unsynchronized access to the map:&lt;pre&gt;</span><span class="hljs-comment"> *   Map m = Collections.synchronizedMap(new HashMap(...));&lt;/pre&gt;</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * &lt;p&gt;The iterators returned by all of this class's "collection view methods"</span><span class="hljs-comment"> * are &lt;i&gt;fail-fast&lt;/i&gt;: if the map is structurally modified at any time after</span><span class="hljs-comment"> * the iterator is created, in any way except through the iterator's own</span><span class="hljs-comment"> * &lt;tt&gt;remove&lt;/tt&gt; method, the iterator will throw a</span><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> ConcurrentModificationException&#125;.  Thus, in the face of concurrent</span><span class="hljs-comment"> * modification, the iterator fails quickly and cleanly, rather than risking</span><span class="hljs-comment"> * arbitrary, non-deterministic behavior at an undetermined time in the</span><span class="hljs-comment"> * future.</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * &lt;p&gt;Note that the fail-fast behavior of an iterator cannot be guaranteed</span><span class="hljs-comment"> * as it is, generally speaking, impossible to make any hard guarantees in the</span><span class="hljs-comment"> * presence of unsynchronized concurrent modification.  Fail-fast iterators</span><span class="hljs-comment"> * throw &lt;tt&gt;ConcurrentModificationException&lt;/tt&gt; on a best-effort basis.</span><span class="hljs-comment"> * Therefore, it would be wrong to write a program that depended on this</span><span class="hljs-comment"> * exception for its correctness: &lt;i&gt;the fail-fast behavior of iterators</span><span class="hljs-comment"> * should be used only to detect bugs.&lt;/i&gt;</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * &lt;p&gt;This class is a member of the</span><span class="hljs-comment"> * &lt;a href="&#123;<span class="hljs-doctag">@docRoot</span>&#125;/../technotes/guides/collections/index.html"&gt;</span><span class="hljs-comment"> * Java Collections Framework&lt;/a&gt;.</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &lt;K&gt; the type of keys maintained by this map</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &lt;V&gt; the type of mapped values</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>  Doug Lea</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>  Josh Bloch</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>  Arthur van Hoff</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>  Neal Gafter</span><span class="hljs-comment"> * <span class="hljs-doctag">@see</span>     Object#hashCode()</span><span class="hljs-comment"> * <span class="hljs-doctag">@see</span>     Collection</span><span class="hljs-comment"> * <span class="hljs-doctag">@see</span>     Map</span><span class="hljs-comment"> * <span class="hljs-doctag">@see</span>     TreeMap</span><span class="hljs-comment"> * <span class="hljs-doctag">@see</span>     Hashtable</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span>   1.2</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashMap</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractMap</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;</span><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">Map</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;, <span class="hljs-title">Cloneable</span>, <span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">362498820763181265L</span>;    <span class="hljs-comment">/*</span><span class="hljs-comment">     * Implementation notes.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * This map usually acts as a binned (bucketed) hash table, but</span><span class="hljs-comment">     * when bins get too large, they are transformed into bins of</span><span class="hljs-comment">     * TreeNodes, each structured similarly to those in</span><span class="hljs-comment">     * java.util.TreeMap. Most methods try to use normal bins, but</span><span class="hljs-comment">     * relay to TreeNode methods when applicable (simply by checking</span><span class="hljs-comment">     * instanceof a node).  Bins of TreeNodes may be traversed and</span><span class="hljs-comment">     * used like any others, but additionally support faster lookup</span><span class="hljs-comment">     * when overpopulated. However, since the vast majority of bins in</span><span class="hljs-comment">     * normal use are not overpopulated, checking for existence of</span><span class="hljs-comment">     * tree bins may be delayed in the course of table methods.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * Tree bins (i.e., bins whose elements are all TreeNodes) are</span><span class="hljs-comment">     * ordered primarily by hashCode, but in the case of ties, if two</span><span class="hljs-comment">     * elements are of the same "class C implements Comparable&lt;C&gt;",</span><span class="hljs-comment">     * type then their compareTo method is used for ordering. (We</span><span class="hljs-comment">     * conservatively check generic types via reflection to validate</span><span class="hljs-comment">     * this -- see method comparableClassFor).  The added complexity</span><span class="hljs-comment">     * of tree bins is worthwhile in providing worst-case O(log n)</span><span class="hljs-comment">     * operations when keys either have distinct hashes or are</span><span class="hljs-comment">     * orderable, Thus, performance degrades gracefully under</span><span class="hljs-comment">     * accidental or malicious usages in which hashCode() methods</span><span class="hljs-comment">     * return values that are poorly distributed, as well as those in</span><span class="hljs-comment">     * which many keys share a hashCode, so long as they are also</span><span class="hljs-comment">     * Comparable. (If neither of these apply, we may waste about a</span><span class="hljs-comment">     * factor of two in time and space compared to taking no</span><span class="hljs-comment">     * precautions. But the only known cases stem from poor user</span><span class="hljs-comment">     * programming practices that are already so slow that this makes</span><span class="hljs-comment">     * little difference.)</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * Because TreeNodes are about twice the size of regular nodes, we</span><span class="hljs-comment">     * use them only when bins contain enough nodes to warrant use</span><span class="hljs-comment">     * (see TREEIFY_THRESHOLD). And when they become too small (due to</span><span class="hljs-comment">     * removal or resizing) they are converted back to plain bins.  In</span><span class="hljs-comment">     * usages with well-distributed user hashCodes, tree bins are</span><span class="hljs-comment">     * rarely used.  Ideally, under random hashCodes, the frequency of</span><span class="hljs-comment">     * nodes in bins follows a Poisson distribution</span><span class="hljs-comment">     * (http://en.wikipedia.org/wiki/Poisson_distribution) with a</span><span class="hljs-comment">     * parameter of about 0.5 on average for the default resizing</span><span class="hljs-comment">     * threshold of 0.75, although with a large variance because of</span><span class="hljs-comment">     * resizing granularity. Ignoring variance, the expected</span><span class="hljs-comment">     * occurrences of list size k are (exp(-0.5) * pow(0.5, k) /</span><span class="hljs-comment">     * factorial(k)). The first values are:</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * 0:    0.60653066</span><span class="hljs-comment">     * 1:    0.30326533</span><span class="hljs-comment">     * 2:    0.07581633</span><span class="hljs-comment">     * 3:    0.01263606</span><span class="hljs-comment">     * 4:    0.00157952</span><span class="hljs-comment">     * 5:    0.00015795</span><span class="hljs-comment">     * 6:    0.00001316</span><span class="hljs-comment">     * 7:    0.00000094</span><span class="hljs-comment">     * 8:    0.00000006</span><span class="hljs-comment">     * more: less than 1 in ten million</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * The root of a tree bin is normally its first node.  However,</span><span class="hljs-comment">     * sometimes (currently only upon Iterator.remove), the root might</span><span class="hljs-comment">     * be elsewhere, but can be recovered following parent links</span><span class="hljs-comment">     * (method TreeNode.root()).</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * All applicable internal methods accept a hash code as an</span><span class="hljs-comment">     * argument (as normally supplied from a public method), allowing</span><span class="hljs-comment">     * them to call each other without recomputing user hashCodes.</span><span class="hljs-comment">     * Most internal methods also accept a "tab" argument, that is</span><span class="hljs-comment">     * normally the current table, but may be a new or old one when</span><span class="hljs-comment">     * resizing or converting.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * When bin lists are treeified, split, or untreeified, we keep</span><span class="hljs-comment">     * them in the same relative access/traversal order (i.e., field</span><span class="hljs-comment">     * Node.next) to better preserve locality, and to slightly</span><span class="hljs-comment">     * simplify handling of splits and traversals that invoke</span><span class="hljs-comment">     * iterator.remove. When using comparators on insertion, to keep a</span><span class="hljs-comment">     * total ordering (or as close as is required here) across</span><span class="hljs-comment">     * rebalancings, we compare classes and identityHashCodes as</span><span class="hljs-comment">     * tie-breakers.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * The use and transitions among plain vs tree modes is</span><span class="hljs-comment">     * complicated by the existence of subclass LinkedHashMap. See</span><span class="hljs-comment">     * below for hook methods defined to be invoked upon insertion,</span><span class="hljs-comment">     * removal and access that allow LinkedHashMap internals to</span><span class="hljs-comment">     * otherwise remain independent of these mechanics. (This also</span><span class="hljs-comment">     * requires that a map instance be passed to some utility methods</span><span class="hljs-comment">     * that may create new nodes.)</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * The concurrent-programming-like SSA-based coding style helps</span><span class="hljs-comment">     * avoid aliasing errors amid all of the twisty pointer operations.</span><span class="hljs-comment">     */</span>    <span class="hljs-comment">/**</span><span class="hljs-comment">     * The default initial capacity - MUST be a power of two.</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>; <span class="hljs-comment">// aka 16</span>    <span class="hljs-comment">/**</span><span class="hljs-comment">     * The maximum capacity, used if a higher value is implicitly specified</span><span class="hljs-comment">     * by either of the constructors with arguments.</span><span class="hljs-comment">     * MUST be a power of two &lt;= 1&lt;&lt;30.</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAXIMUM_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * The load factor used when none specified in constructor.</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="hljs-number">0.75f</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * The bin count threshold for using a tree rather than list for a</span><span class="hljs-comment">     * bin.  Bins are converted to trees when adding an element to a</span><span class="hljs-comment">     * bin with at least this many nodes. The value must be greater</span><span class="hljs-comment">     * than 2 and should be at least 8 to mesh with assumptions in</span><span class="hljs-comment">     * tree removal about conversion back to plain bins upon</span><span class="hljs-comment">     * shrinkage.</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TREEIFY_THRESHOLD = <span class="hljs-number">8</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * The bin count threshold for untreeifying a (split) bin during a</span><span class="hljs-comment">     * resize operation. Should be less than TREEIFY_THRESHOLD, and at</span><span class="hljs-comment">     * most 6 to mesh with shrinkage detection under removal.</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> UNTREEIFY_THRESHOLD = <span class="hljs-number">6</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * The smallest table capacity for which bins may be treeified.</span><span class="hljs-comment">     * (Otherwise the table is resized if too many nodes in a bin.)</span><span class="hljs-comment">     * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts</span><span class="hljs-comment">     * between resizing and treeification thresholds.</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="hljs-number">64</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Basic hash bin node, used for most entries.  (See below for</span><span class="hljs-comment">     * TreeNode subclass, and in LinkedHashMap for its Entry subclass.)</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Map</span>.<span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> hash;        <span class="hljs-keyword">final</span> K key;        V value;        Node&lt;K,V&gt; next;        Node(<span class="hljs-keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;            <span class="hljs-keyword">this</span>.hash = hash;            <span class="hljs-keyword">this</span>.key = key;            <span class="hljs-keyword">this</span>.value = value;            <span class="hljs-keyword">this</span>.next = next;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> K <span class="hljs-title">getKey</span><span class="hljs-params">()</span>        </span>&#123; <span class="hljs-keyword">return</span> key; &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title">getValue</span><span class="hljs-params">()</span>      </span>&#123; <span class="hljs-keyword">return</span> value; &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> key + <span class="hljs-string">"="</span> + value; &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title">setValue</span><span class="hljs-params">(V newValue)</span> </span>&#123;            V oldValue = value;            value = newValue;            <span class="hljs-keyword">return</span> oldValue;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;            <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">this</span>)                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            <span class="hljs-keyword">if</span> (o <span class="hljs-keyword">instanceof</span> Map.Entry) &#123;                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;                <span class="hljs-keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;                    Objects.equals(value, e.getValue()))                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;    &#125;    <span class="hljs-comment">/* ---------------- Static utilities -------------- */</span>    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Computes key.hashCode() and spreads (XORs) higher bits of hash</span><span class="hljs-comment">     * to lower.  Because the table uses power-of-two masking, sets of</span><span class="hljs-comment">     * hashes that vary only in bits above the current mask will</span><span class="hljs-comment">     * always collide. (Among known examples are sets of Float keys</span><span class="hljs-comment">     * holding consecutive whole numbers in small tables.)  So we</span><span class="hljs-comment">     * apply a transform that spreads the impact of higher bits</span><span class="hljs-comment">     * downward. There is a tradeoff between speed, utility, and</span><span class="hljs-comment">     * quality of bit-spreading. Because many common sets of hashes</span><span class="hljs-comment">     * are already reasonably distributed (so don't benefit from</span><span class="hljs-comment">     * spreading), and because we use trees to handle large sets of</span><span class="hljs-comment">     * collisions in bins, we just XOR some shifted bits in the</span><span class="hljs-comment">     * cheapest possible way to reduce systematic lossage, as well as</span><span class="hljs-comment">     * to incorporate impact of the highest bits that would otherwise</span><span class="hljs-comment">     * never be used in index calculations because of table bounds.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(Object key)</span> </span>&#123;        <span class="hljs-keyword">int</span> h;        <span class="hljs-keyword">return</span> (key == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Returns x's Class if it is of the form "class C implements</span><span class="hljs-comment">     * Comparable&lt;C&gt;", else null.</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">static</span> Class&lt;?&gt; comparableClassFor(Object x) &#123;        <span class="hljs-keyword">if</span> (x <span class="hljs-keyword">instanceof</span> Comparable) &#123;            Class&lt;?&gt; c; Type[] ts, as; Type t; ParameterizedType p;            <span class="hljs-keyword">if</span> ((c = x.getClass()) == String<span class="hljs-class">.<span class="hljs-keyword">class</span>) // <span class="hljs-title">bypass</span> <span class="hljs-title">checks</span></span><span class="hljs-class">                <span class="hljs-title">return</span> <span class="hljs-title">c</span></span>;            <span class="hljs-keyword">if</span> ((ts = c.getGenericInterfaces()) != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ts.length; ++i) &#123;                    <span class="hljs-keyword">if</span> (((t = ts[i]) <span class="hljs-keyword">instanceof</span> ParameterizedType) &amp;&amp;                        ((p = (ParameterizedType)t).getRawType() ==                         Comparable<span class="hljs-class">.<span class="hljs-keyword">class</span>) &amp;&amp;</span><span class="hljs-class">                        (<span class="hljs-title">as</span> </span>= p.getActualTypeArguments()) != <span class="hljs-keyword">null</span> &amp;&amp;                        as.length == <span class="hljs-number">1</span> &amp;&amp; as[<span class="hljs-number">0</span>] == c) <span class="hljs-comment">// type arg is c</span>                        <span class="hljs-keyword">return</span> c;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Returns k.compareTo(x) if x matches kc (k's screened comparable</span><span class="hljs-comment">     * class), else 0.</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@SuppressWarnings</span>(&#123;<span class="hljs-string">"rawtypes"</span>,<span class="hljs-string">"unchecked"</span>&#125;) <span class="hljs-comment">// for cast to Comparable</span>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareComparables</span><span class="hljs-params">(Class&lt;?&gt; kc, Object k, Object x)</span> </span>&#123;        <span class="hljs-keyword">return</span> (x == <span class="hljs-keyword">null</span> || x.getClass() != kc ? <span class="hljs-number">0</span> :                ((Comparable)k).compareTo(x));    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Returns a power of two size for the given target capacity.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">tableSizeFor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cap)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = cap - <span class="hljs-number">1</span>;        n |= n &gt;&gt;&gt; <span class="hljs-number">1</span>;        n |= n &gt;&gt;&gt; <span class="hljs-number">2</span>;        n |= n &gt;&gt;&gt; <span class="hljs-number">4</span>;        n |= n &gt;&gt;&gt; <span class="hljs-number">8</span>;        n |= n &gt;&gt;&gt; <span class="hljs-number">16</span>;        <span class="hljs-keyword">return</span> (n &lt; <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="hljs-number">1</span>;    &#125;    <span class="hljs-comment">/* ---------------- Fields -------------- */</span>    <span class="hljs-comment">/**</span><span class="hljs-comment">     * The table, initialized on first use, and resized as</span><span class="hljs-comment">     * necessary. When allocated, length is always a power of two.</span><span class="hljs-comment">     * (We also tolerate length zero in some operations to allow</span><span class="hljs-comment">     * bootstrapping mechanics that are currently not needed.)</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">transient</span> Node&lt;K,V&gt;[] table;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Holds cached entrySet(). Note that AbstractMap fields are used</span><span class="hljs-comment">     * for keySet() and values().</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * The number of key-value mappings contained in this map.</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> size;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * The number of times this HashMap has been structurally modified</span><span class="hljs-comment">     * Structural modifications are those that change the number of mappings in</span><span class="hljs-comment">     * the HashMap or otherwise modify its internal structure (e.g.,</span><span class="hljs-comment">     * rehash).  This field is used to make iterators on Collection-views of</span><span class="hljs-comment">     * the HashMap fail-fast.  (See ConcurrentModificationException).</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> modCount;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * The next size value at which to resize (capacity * load factor).</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@serial</span></span><span class="hljs-comment">     */</span>    <span class="hljs-comment">// (The javadoc description is true upon serialization.</span>    <span class="hljs-comment">// Additionally, if the table array has not been allocated, this</span>    <span class="hljs-comment">// field holds the initial array capacity, or zero signifying</span>    <span class="hljs-comment">// DEFAULT_INITIAL_CAPACITY.)</span>    <span class="hljs-keyword">int</span> threshold;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * The load factor for the hash table.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@serial</span></span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> loadFactor;    <span class="hljs-comment">/* ---------------- Public operations -------------- */</span>    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial</span><span class="hljs-comment">     * capacity and load factor.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span>  initialCapacity the initial capacity</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span>  loadFactor      the load factor</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IllegalArgumentException if the initial capacity is negative</span><span class="hljs-comment">     *         or the load factor is nonpositive</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity, <span class="hljs-keyword">float</span> loadFactor)</span> </span>&#123;        <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Illegal initial capacity: "</span> +                                               initialCapacity);        <span class="hljs-keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)            initialCapacity = MAXIMUM_CAPACITY;        <span class="hljs-keyword">if</span> (loadFactor &lt;= <span class="hljs-number">0</span> || Float.isNaN(loadFactor))            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Illegal load factor: "</span> +                                               loadFactor);        <span class="hljs-keyword">this</span>.loadFactor = loadFactor;        <span class="hljs-keyword">this</span>.threshold = tableSizeFor(initialCapacity);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial</span><span class="hljs-comment">     * capacity and the default load factor (0.75).</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span>  initialCapacity the initial capacity.</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IllegalArgumentException if the initial capacity is negative.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity)</span> </span>&#123;        <span class="hljs-keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity</span><span class="hljs-comment">     * (16) and the default load factor (0.75).</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="hljs-comment">// all other fields defaulted</span>    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Constructs a new &lt;tt&gt;HashMap&lt;/tt&gt; with the same mappings as the</span><span class="hljs-comment">     * specified &lt;tt&gt;Map&lt;/tt&gt;.  The &lt;tt&gt;HashMap&lt;/tt&gt; is created with</span><span class="hljs-comment">     * default load factor (0.75) and an initial capacity sufficient to</span><span class="hljs-comment">     * hold the mappings in the specified &lt;tt&gt;Map&lt;/tt&gt;.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span>   m the map whose mappings are to be placed in this map</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span>  NullPointerException if the specified map is null</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;        <span class="hljs-keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;        putMapEntries(m, <span class="hljs-keyword">false</span>);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Implements Map.putAll and Map constructor.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> m the map</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> evict false when initially constructing this map, else</span><span class="hljs-comment">     * true (relayed to method afterNodeInsertion).</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">putMapEntries</span><span class="hljs-params">(Map&lt;? extends K, ? extends V&gt; m, <span class="hljs-keyword">boolean</span> evict)</span> </span>&#123;        <span class="hljs-keyword">int</span> s = m.size();        <span class="hljs-keyword">if</span> (s &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">if</span> (table == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// pre-size</span>                <span class="hljs-keyword">float</span> ft = ((<span class="hljs-keyword">float</span>)s / loadFactor) + <span class="hljs-number">1.0F</span>;                <span class="hljs-keyword">int</span> t = ((ft &lt; (<span class="hljs-keyword">float</span>)MAXIMUM_CAPACITY) ?                         (<span class="hljs-keyword">int</span>)ft : MAXIMUM_CAPACITY);                <span class="hljs-keyword">if</span> (t &gt; threshold)                    threshold = tableSizeFor(t);            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s &gt; threshold)                resize();            <span class="hljs-keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;                K key = e.getKey();                V value = e.getValue();                putVal(hash(key), key, value, <span class="hljs-keyword">false</span>, evict);            &#125;        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Returns the number of key-value mappings in this map.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> the number of key-value mappings in this map</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> size;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Returns &lt;tt&gt;true&lt;/tt&gt; if this map contains no key-value mappings.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if this map contains no key-value mappings</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> size == <span class="hljs-number">0</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Returns the value to which the specified key is mapped,</span><span class="hljs-comment">     * or &#123;<span class="hljs-doctag">@code</span> null&#125; if this map contains no mapping for the key.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * &lt;p&gt;More formally, if this map contains a mapping from a key</span><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@code</span> k&#125; to a value &#123;<span class="hljs-doctag">@code</span> v&#125; such that &#123;<span class="hljs-doctag">@code</span> (key==null ? k==null :</span><span class="hljs-comment">     * key.equals(k))&#125;, then this method returns &#123;<span class="hljs-doctag">@code</span> v&#125;; otherwise</span><span class="hljs-comment">     * it returns &#123;<span class="hljs-doctag">@code</span> null&#125;.  (There can be at most one such mapping.)</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * &lt;p&gt;A return value of &#123;<span class="hljs-doctag">@code</span> null&#125; does not &lt;i&gt;necessarily&lt;/i&gt;</span><span class="hljs-comment">     * indicate that the map contains no mapping for the key; it's also</span><span class="hljs-comment">     * possible that the map explicitly maps the key to &#123;<span class="hljs-doctag">@code</span> null&#125;.</span><span class="hljs-comment">     * The &#123;<span class="hljs-doctag">@link</span> #containsKey containsKey&#125; operation may be used to</span><span class="hljs-comment">     * distinguish these two cases.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@see</span> #put(Object, Object)</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">get</span><span class="hljs-params">(Object key)</span> </span>&#123;        Node&lt;K,V&gt; e;        <span class="hljs-keyword">return</span> (e = getNode(hash(key), key)) == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : e.value;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Implements Map.get and related methods.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> hash hash for key</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key the key</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> the node, or null if none</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">final</span> Node&lt;K,V&gt; <span class="hljs-title">getNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, Object key)</span> </span>&#123;        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="hljs-keyword">int</span> n; K k;        <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;            (first = tab[(n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">if</span> (first.hash == hash &amp;&amp; <span class="hljs-comment">// always check first node</span>                ((k = first.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))                <span class="hljs-keyword">return</span> first;            <span class="hljs-keyword">if</span> ((e = first.next) != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">if</span> (first <span class="hljs-keyword">instanceof</span> TreeNode)                    <span class="hljs-keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);                <span class="hljs-keyword">do</span> &#123;                    <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;                        ((k = e.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))                        <span class="hljs-keyword">return</span> e;                &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-keyword">null</span>);            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Returns &lt;tt&gt;true&lt;/tt&gt; if this map contains a mapping for the</span><span class="hljs-comment">     * specified key.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span>   key   The key whose presence in this map is to be tested</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if this map contains a mapping for the specified</span><span class="hljs-comment">     * key.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">containsKey</span><span class="hljs-params">(Object key)</span> </span>&#123;        <span class="hljs-keyword">return</span> getNode(hash(key), key) != <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Associates the specified value with the specified key in this map.</span><span class="hljs-comment">     * If the map previously contained a mapping for the key, the old</span><span class="hljs-comment">     * value is replaced.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key key with which the specified value is to be associated</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value value to be associated with the specified key</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or</span><span class="hljs-comment">     *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;.</span><span class="hljs-comment">     *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map</span><span class="hljs-comment">     *         previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.)</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>&#123;        <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Implements Map.put and related methods.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> hash hash for key</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key the key</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value the value to put</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> onlyIfAbsent if true, don't change existing value</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> evict if false, the table is in creation mode.</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> previous value, or null if none</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">final</span> V <span class="hljs-title">putVal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, K key, V value, <span class="hljs-keyword">boolean</span> onlyIfAbsent,</span></span><span class="hljs-function"><span class="hljs-params">                   <span class="hljs-keyword">boolean</span> evict)</span> </span>&#123;        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-keyword">int</span> n, i;        <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-keyword">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)            n = (tab = resize()).length;        <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-keyword">null</span>)            tab[i] = newNode(hash, key, value, <span class="hljs-keyword">null</span>);        <span class="hljs-keyword">else</span> &#123;            Node&lt;K,V&gt; e; K k;            <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;                ((k = p.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))                e = p;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-keyword">this</span>, tab, hash, key, value);            <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> binCount = <span class="hljs-number">0</span>; ; ++binCount) &#123;                    <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-keyword">null</span>) &#123;                        p.next = newNode(hash, key, value, <span class="hljs-keyword">null</span>);                        <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span>                            treeifyBin(tab, hash);                        <span class="hljs-keyword">break</span>;                    &#125;                    <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;                        ((k = e.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))                        <span class="hljs-keyword">break</span>;                    p = e;                &#125;            &#125;            <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// existing mapping for key</span>                V oldValue = e.value;                <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-keyword">null</span>)                    e.value = value;                afterNodeAccess(e);                <span class="hljs-keyword">return</span> oldValue;            &#125;        &#125;        ++modCount;        <span class="hljs-keyword">if</span> (++size &gt; threshold)            resize();        afterNodeInsertion(evict);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Initializes or doubles table size.  If null, allocates in</span><span class="hljs-comment">     * accord with initial capacity target held in field threshold.</span><span class="hljs-comment">     * Otherwise, because we are using power-of-two expansion, the</span><span class="hljs-comment">     * elements from each bin must either stay at same index, or move</span><span class="hljs-comment">     * with a power of two offset in the new table.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> the table</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;        Node&lt;K,V&gt;[] oldTab = table;        <span class="hljs-keyword">int</span> oldCap = (oldTab == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : oldTab.length;        <span class="hljs-keyword">int</span> oldThr = threshold;        <span class="hljs-keyword">int</span> newCap, newThr = <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;                threshold = Integer.MAX_VALUE;                <span class="hljs-keyword">return</span> oldTab;            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)                newThr = oldThr &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// double threshold</span>        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// initial capacity was placed in threshold</span>            newCap = oldThr;        <span class="hljs-keyword">else</span> &#123;               <span class="hljs-comment">// zero initial threshold signifies using defaults</span>            newCap = DEFAULT_INITIAL_CAPACITY;            newThr = (<span class="hljs-keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);        &#125;        <span class="hljs-keyword">if</span> (newThr == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">float</span> ft = (<span class="hljs-keyword">float</span>)newCap * loadFactor;            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="hljs-keyword">float</span>)MAXIMUM_CAPACITY ?                      (<span class="hljs-keyword">int</span>)ft : Integer.MAX_VALUE);        &#125;        threshold = newThr;        <span class="hljs-meta">@SuppressWarnings</span>(&#123;<span class="hljs-string">"rawtypes"</span>,<span class="hljs-string">"unchecked"</span>&#125;)        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> Node[newCap];        table = newTab;        <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; oldCap; ++j) &#123;                Node&lt;K,V&gt; e;                <span class="hljs-keyword">if</span> ((e = oldTab[j]) != <span class="hljs-keyword">null</span>) &#123;                    oldTab[j] = <span class="hljs-keyword">null</span>;                    <span class="hljs-keyword">if</span> (e.next == <span class="hljs-keyword">null</span>)                        newTab[e.hash &amp; (newCap - <span class="hljs-number">1</span>)] = e;                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> TreeNode)                        ((TreeNode&lt;K,V&gt;)e).split(<span class="hljs-keyword">this</span>, newTab, j, oldCap);                    <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// preserve order</span>                        Node&lt;K,V&gt; loHead = <span class="hljs-keyword">null</span>, loTail = <span class="hljs-keyword">null</span>;                        Node&lt;K,V&gt; hiHead = <span class="hljs-keyword">null</span>, hiTail = <span class="hljs-keyword">null</span>;                        Node&lt;K,V&gt; next;                        <span class="hljs-keyword">do</span> &#123;                            next = e.next;                            <span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) &#123;                                <span class="hljs-keyword">if</span> (loTail == <span class="hljs-keyword">null</span>)                                    loHead = e;                                <span class="hljs-keyword">else</span>                                    loTail.next = e;                                loTail = e;                            &#125;                            <span class="hljs-keyword">else</span> &#123;                                <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-keyword">null</span>)                                    hiHead = e;                                <span class="hljs-keyword">else</span>                                    hiTail.next = e;                                hiTail = e;                            &#125;                        &#125; <span class="hljs-keyword">while</span> ((e = next) != <span class="hljs-keyword">null</span>);                        <span class="hljs-keyword">if</span> (loTail != <span class="hljs-keyword">null</span>) &#123;                            loTail.next = <span class="hljs-keyword">null</span>;                            newTab[j] = loHead;                        &#125;                        <span class="hljs-keyword">if</span> (hiTail != <span class="hljs-keyword">null</span>) &#123;                            hiTail.next = <span class="hljs-keyword">null</span>;                            newTab[j + oldCap] = hiHead;                        &#125;                    &#125;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> newTab;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Replaces all linked nodes in bin at index for given hash unless</span><span class="hljs-comment">     * table is too small, in which case resizes instead.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">treeifyBin</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-keyword">int</span> hash)</span> </span>&#123;        <span class="hljs-keyword">int</span> n, index; Node&lt;K,V&gt; e;        <span class="hljs-keyword">if</span> (tab == <span class="hljs-keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)            resize();        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((e = tab[index = (n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-keyword">null</span>) &#123;            TreeNode&lt;K,V&gt; hd = <span class="hljs-keyword">null</span>, tl = <span class="hljs-keyword">null</span>;            <span class="hljs-keyword">do</span> &#123;                TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="hljs-keyword">null</span>);                <span class="hljs-keyword">if</span> (tl == <span class="hljs-keyword">null</span>)                    hd = p;                <span class="hljs-keyword">else</span> &#123;                    p.prev = tl;                    tl.next = p;                &#125;                tl = p;            &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-keyword">null</span>);            <span class="hljs-keyword">if</span> ((tab[index] = hd) != <span class="hljs-keyword">null</span>)                hd.treeify(tab);        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Copies all of the mappings from the specified map to this map.</span><span class="hljs-comment">     * These mappings will replace any mappings that this map had for</span><span class="hljs-comment">     * any of the keys currently in the specified map.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> m mappings to be stored in this map</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> NullPointerException if the specified map is null</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">putAll</span><span class="hljs-params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;        putMapEntries(m, <span class="hljs-keyword">true</span>);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Removes the mapping for the specified key from this map if present.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span>  key key whose mapping is to be removed from the map</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or</span><span class="hljs-comment">     *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;.</span><span class="hljs-comment">     *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map</span><span class="hljs-comment">     *         previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.)</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">remove</span><span class="hljs-params">(Object key)</span> </span>&#123;        Node&lt;K,V&gt; e;        <span class="hljs-keyword">return</span> (e = removeNode(hash(key), key, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>)) == <span class="hljs-keyword">null</span> ?            <span class="hljs-keyword">null</span> : e.value;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Implements Map.remove and related methods.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> hash hash for key</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key the key</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value the value to match if matchValue, else ignored</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> matchValue if true only remove if value is equal</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> movable if false do not move other nodes while removing</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> the node, or null if none</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">final</span> Node&lt;K,V&gt; <span class="hljs-title">removeNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, Object key, Object value,</span></span><span class="hljs-function"><span class="hljs-params">                               <span class="hljs-keyword">boolean</span> matchValue, <span class="hljs-keyword">boolean</span> movable)</span> </span>&#123;        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-keyword">int</span> n, index;        <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;            (p = tab[index = (n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-keyword">null</span>) &#123;            Node&lt;K,V&gt; node = <span class="hljs-keyword">null</span>, e; K k; V v;            <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;                ((k = p.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))                node = p;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((e = p.next) != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)                    node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);                <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-keyword">do</span> &#123;                        <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;                            ((k = e.key) == key ||                             (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k)))) &#123;                            node = e;                            <span class="hljs-keyword">break</span>;                        &#125;                        p = e;                    &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-keyword">null</span>);                &#125;            &#125;            <span class="hljs-keyword">if</span> (node != <span class="hljs-keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||                                 (value != <span class="hljs-keyword">null</span> &amp;&amp; value.equals(v)))) &#123;                <span class="hljs-keyword">if</span> (node <span class="hljs-keyword">instanceof</span> TreeNode)                    ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="hljs-keyword">this</span>, tab, movable);                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node == p)                    tab[index] = node.next;                <span class="hljs-keyword">else</span>                    p.next = node.next;                ++modCount;                --size;                afterNodeRemoval(node);                <span class="hljs-keyword">return</span> node;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Removes all of the mappings from this map.</span><span class="hljs-comment">     * The map will be empty after this call returns.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123;        Node&lt;K,V&gt;[] tab;        modCount++;        <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-keyword">null</span> &amp;&amp; size &gt; <span class="hljs-number">0</span>) &#123;            size = <span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; tab.length; ++i)                tab[i] = <span class="hljs-keyword">null</span>;        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Returns &lt;tt&gt;true&lt;/tt&gt; if this map maps one or more keys to the</span><span class="hljs-comment">     * specified value.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value value whose presence in this map is to be tested</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if this map maps one or more keys to the</span><span class="hljs-comment">     *         specified value</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">containsValue</span><span class="hljs-params">(Object value)</span> </span>&#123;        Node&lt;K,V&gt;[] tab; V v;        <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-keyword">null</span> &amp;&amp; size &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; tab.length; ++i) &#123;                <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="hljs-keyword">null</span>; e = e.next) &#123;                    <span class="hljs-keyword">if</span> ((v = e.value) == value ||                        (value != <span class="hljs-keyword">null</span> &amp;&amp; value.equals(v)))                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Returns a &#123;<span class="hljs-doctag">@link</span> Set&#125; view of the keys contained in this map.</span><span class="hljs-comment">     * The set is backed by the map, so changes to the map are</span><span class="hljs-comment">     * reflected in the set, and vice-versa.  If the map is modified</span><span class="hljs-comment">     * while an iteration over the set is in progress (except through</span><span class="hljs-comment">     * the iterator's own &lt;tt&gt;remove&lt;/tt&gt; operation), the results of</span><span class="hljs-comment">     * the iteration are undefined.  The set supports element removal,</span><span class="hljs-comment">     * which removes the corresponding mapping from the map, via the</span><span class="hljs-comment">     * &lt;tt&gt;Iterator.remove&lt;/tt&gt;, &lt;tt&gt;Set.remove&lt;/tt&gt;,</span><span class="hljs-comment">     * &lt;tt&gt;removeAll&lt;/tt&gt;, &lt;tt&gt;retainAll&lt;/tt&gt;, and &lt;tt&gt;clear&lt;/tt&gt;</span><span class="hljs-comment">     * operations.  It does not support the &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt;</span><span class="hljs-comment">     * operations.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> a set view of the keys contained in this map</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Set&lt;K&gt; <span class="hljs-title">keySet</span><span class="hljs-params">()</span> </span>&#123;        Set&lt;K&gt; ks = keySet;        <span class="hljs-keyword">if</span> (ks == <span class="hljs-keyword">null</span>) &#123;            ks = <span class="hljs-keyword">new</span> KeySet();            keySet = ks;        &#125;        <span class="hljs-keyword">return</span> ks;    &#125;    <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KeySet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractSet</span>&lt;<span class="hljs-title">K</span>&gt; </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span>                 </span>&#123; <span class="hljs-keyword">return</span> size; &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span>               </span>&#123; HashMap.<span class="hljs-keyword">this</span>.clear(); &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Iterator&lt;K&gt; <span class="hljs-title">iterator</span><span class="hljs-params">()</span>     </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> KeyIterator(); &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">contains</span><span class="hljs-params">(Object o)</span> </span>&#123; <span class="hljs-keyword">return</span> containsKey(o); &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">remove</span><span class="hljs-params">(Object key)</span> </span>&#123;            <span class="hljs-keyword">return</span> removeNode(hash(key), key, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>) != <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Spliterator&lt;K&gt; <span class="hljs-title">spliterator</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> KeySpliterator&lt;&gt;(HashMap.<span class="hljs-keyword">this</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">forEach</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-keyword">super</span> K&gt; action)</span> </span>&#123;            Node&lt;K,V&gt;[] tab;            <span class="hljs-keyword">if</span> (action == <span class="hljs-keyword">null</span>)                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();            <span class="hljs-keyword">if</span> (size &gt; <span class="hljs-number">0</span> &amp;&amp; (tab = table) != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">int</span> mc = modCount;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; tab.length; ++i) &#123;                    <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="hljs-keyword">null</span>; e = e.next)                        action.accept(e.key);                &#125;                <span class="hljs-keyword">if</span> (modCount != mc)                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();            &#125;        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Returns a &#123;<span class="hljs-doctag">@link</span> Collection&#125; view of the values contained in this map.</span><span class="hljs-comment">     * The collection is backed by the map, so changes to the map are</span><span class="hljs-comment">     * reflected in the collection, and vice-versa.  If the map is</span><span class="hljs-comment">     * modified while an iteration over the collection is in progress</span><span class="hljs-comment">     * (except through the iterator's own &lt;tt&gt;remove&lt;/tt&gt; operation),</span><span class="hljs-comment">     * the results of the iteration are undefined.  The collection</span><span class="hljs-comment">     * supports element removal, which removes the corresponding</span><span class="hljs-comment">     * mapping from the map, via the &lt;tt&gt;Iterator.remove&lt;/tt&gt;,</span><span class="hljs-comment">     * &lt;tt&gt;Collection.remove&lt;/tt&gt;, &lt;tt&gt;removeAll&lt;/tt&gt;,</span><span class="hljs-comment">     * &lt;tt&gt;retainAll&lt;/tt&gt; and &lt;tt&gt;clear&lt;/tt&gt; operations.  It does not</span><span class="hljs-comment">     * support the &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt; operations.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> a view of the values contained in this map</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Collection&lt;V&gt; <span class="hljs-title">values</span><span class="hljs-params">()</span> </span>&#123;        Collection&lt;V&gt; vs = values;        <span class="hljs-keyword">if</span> (vs == <span class="hljs-keyword">null</span>) &#123;            vs = <span class="hljs-keyword">new</span> Values();            values = vs;        &#125;        <span class="hljs-keyword">return</span> vs;    &#125;    <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Values</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractCollection</span>&lt;<span class="hljs-title">V</span>&gt; </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span>                 </span>&#123; <span class="hljs-keyword">return</span> size; &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span>               </span>&#123; HashMap.<span class="hljs-keyword">this</span>.clear(); &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Iterator&lt;V&gt; <span class="hljs-title">iterator</span><span class="hljs-params">()</span>     </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ValueIterator(); &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">contains</span><span class="hljs-params">(Object o)</span> </span>&#123; <span class="hljs-keyword">return</span> containsValue(o); &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Spliterator&lt;V&gt; <span class="hljs-title">spliterator</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ValueSpliterator&lt;&gt;(HashMap.<span class="hljs-keyword">this</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">forEach</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-keyword">super</span> V&gt; action)</span> </span>&#123;            Node&lt;K,V&gt;[] tab;            <span class="hljs-keyword">if</span> (action == <span class="hljs-keyword">null</span>)                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();            <span class="hljs-keyword">if</span> (size &gt; <span class="hljs-number">0</span> &amp;&amp; (tab = table) != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">int</span> mc = modCount;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; tab.length; ++i) &#123;                    <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="hljs-keyword">null</span>; e = e.next)                        action.accept(e.value);                &#125;                <span class="hljs-keyword">if</span> (modCount != mc)                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();            &#125;        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Returns a &#123;<span class="hljs-doctag">@link</span> Set&#125; view of the mappings contained in this map.</span><span class="hljs-comment">     * The set is backed by the map, so changes to the map are</span><span class="hljs-comment">     * reflected in the set, and vice-versa.  If the map is modified</span><span class="hljs-comment">     * while an iteration over the set is in progress (except through</span><span class="hljs-comment">     * the iterator's own &lt;tt&gt;remove&lt;/tt&gt; operation, or through the</span><span class="hljs-comment">     * &lt;tt&gt;setValue&lt;/tt&gt; operation on a map entry returned by the</span><span class="hljs-comment">     * iterator) the results of the iteration are undefined.  The set</span><span class="hljs-comment">     * supports element removal, which removes the corresponding</span><span class="hljs-comment">     * mapping from the map, via the &lt;tt&gt;Iterator.remove&lt;/tt&gt;,</span><span class="hljs-comment">     * &lt;tt&gt;Set.remove&lt;/tt&gt;, &lt;tt&gt;removeAll&lt;/tt&gt;, &lt;tt&gt;retainAll&lt;/tt&gt; and</span><span class="hljs-comment">     * &lt;tt&gt;clear&lt;/tt&gt; operations.  It does not support the</span><span class="hljs-comment">     * &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt; operations.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> a set view of the mappings contained in this map</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;        Set&lt;Map.Entry&lt;K,V&gt;&gt; es;        <span class="hljs-keyword">return</span> (es = entrySet) == <span class="hljs-keyword">null</span> ? (entrySet = <span class="hljs-keyword">new</span> EntrySet()) : es;    &#125;    <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EntrySet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractSet</span>&lt;<span class="hljs-title">Map</span>.<span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;&gt; </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span>                 </span>&#123; <span class="hljs-keyword">return</span> size; &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span>               </span>&#123; HashMap.<span class="hljs-keyword">this</span>.clear(); &#125;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> EntryIterator();        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">contains</span><span class="hljs-params">(Object o)</span> </span>&#123;            <span class="hljs-keyword">if</span> (!(o <span class="hljs-keyword">instanceof</span> Map.Entry))                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;            Object key = e.getKey();            Node&lt;K,V&gt; candidate = getNode(hash(key), key);            <span class="hljs-keyword">return</span> candidate != <span class="hljs-keyword">null</span> &amp;&amp; candidate.equals(e);        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">remove</span><span class="hljs-params">(Object o)</span> </span>&#123;            <span class="hljs-keyword">if</span> (o <span class="hljs-keyword">instanceof</span> Map.Entry) &#123;                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;                Object key = e.getKey();                Object value = e.getValue();                <span class="hljs-keyword">return</span> removeNode(hash(key), key, value, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">true</span>) != <span class="hljs-keyword">null</span>;            &#125;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; spliterator() &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> EntrySpliterator&lt;&gt;(HashMap.<span class="hljs-keyword">this</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">forEach</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-keyword">super</span> Map.Entry&lt;K,V&gt;&gt; action)</span> </span>&#123;            Node&lt;K,V&gt;[] tab;            <span class="hljs-keyword">if</span> (action == <span class="hljs-keyword">null</span>)                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();            <span class="hljs-keyword">if</span> (size &gt; <span class="hljs-number">0</span> &amp;&amp; (tab = table) != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">int</span> mc = modCount;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; tab.length; ++i) &#123;                    <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="hljs-keyword">null</span>; e = e.next)                        action.accept(e);                &#125;                <span class="hljs-keyword">if</span> (modCount != mc)                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();            &#125;        &#125;    &#125;    <span class="hljs-comment">// Overrides of JDK8 Map extension methods</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">getOrDefault</span><span class="hljs-params">(Object key, V defaultValue)</span> </span>&#123;        Node&lt;K,V&gt; e;        <span class="hljs-keyword">return</span> (e = getNode(hash(key), key)) == <span class="hljs-keyword">null</span> ? defaultValue : e.value;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">putIfAbsent</span><span class="hljs-params">(K key, V value)</span> </span>&#123;        <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">true</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">remove</span><span class="hljs-params">(Object key, Object value)</span> </span>&#123;        <span class="hljs-keyword">return</span> removeNode(hash(key), key, value, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">true</span>) != <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">replace</span><span class="hljs-params">(K key, V oldValue, V newValue)</span> </span>&#123;        Node&lt;K,V&gt; e; V v;        <span class="hljs-keyword">if</span> ((e = getNode(hash(key), key)) != <span class="hljs-keyword">null</span> &amp;&amp;            ((v = e.value) == oldValue || (v != <span class="hljs-keyword">null</span> &amp;&amp; v.equals(oldValue)))) &#123;            e.value = newValue;            afterNodeAccess(e);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">replace</span><span class="hljs-params">(K key, V value)</span> </span>&#123;        Node&lt;K,V&gt; e;        <span class="hljs-keyword">if</span> ((e = getNode(hash(key), key)) != <span class="hljs-keyword">null</span>) &#123;            V oldValue = e.value;            e.value = value;            afterNodeAccess(e);            <span class="hljs-keyword">return</span> oldValue;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">computeIfAbsent</span><span class="hljs-params">(K key,</span></span><span class="hljs-function"><span class="hljs-params">                             Function&lt;? <span class="hljs-keyword">super</span> K, ? extends V&gt; mappingFunction)</span> </span>&#123;        <span class="hljs-keyword">if</span> (mappingFunction == <span class="hljs-keyword">null</span>)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();        <span class="hljs-keyword">int</span> hash = hash(key);        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; <span class="hljs-keyword">int</span> n, i;        <span class="hljs-keyword">int</span> binCount = <span class="hljs-number">0</span>;        TreeNode&lt;K,V&gt; t = <span class="hljs-keyword">null</span>;        Node&lt;K,V&gt; old = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">if</span> (size &gt; threshold || (tab = table) == <span class="hljs-keyword">null</span> ||            (n = tab.length) == <span class="hljs-number">0</span>)            n = (tab = resize()).length;        <span class="hljs-keyword">if</span> ((first = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">if</span> (first <span class="hljs-keyword">instanceof</span> TreeNode)                old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);            <span class="hljs-keyword">else</span> &#123;                Node&lt;K,V&gt; e = first; K k;                <span class="hljs-keyword">do</span> &#123;                    <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;                        ((k = e.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k)))) &#123;                        old = e;                        <span class="hljs-keyword">break</span>;                    &#125;                    ++binCount;                &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-keyword">null</span>);            &#125;            V oldValue;            <span class="hljs-keyword">if</span> (old != <span class="hljs-keyword">null</span> &amp;&amp; (oldValue = old.value) != <span class="hljs-keyword">null</span>) &#123;                afterNodeAccess(old);                <span class="hljs-keyword">return</span> oldValue;            &#125;        &#125;        V v = mappingFunction.apply(key);        <span class="hljs-keyword">if</span> (v == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (old != <span class="hljs-keyword">null</span>) &#123;            old.value = v;            afterNodeAccess(old);            <span class="hljs-keyword">return</span> v;        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (t != <span class="hljs-keyword">null</span>)            t.putTreeVal(<span class="hljs-keyword">this</span>, tab, hash, key, v);        <span class="hljs-keyword">else</span> &#123;            tab[i] = newNode(hash, key, v, first);            <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>)                treeifyBin(tab, hash);        &#125;        ++modCount;        ++size;        afterNodeInsertion(<span class="hljs-keyword">true</span>);        <span class="hljs-keyword">return</span> v;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">computeIfPresent</span><span class="hljs-params">(K key,</span></span><span class="hljs-function"><span class="hljs-params">                              BiFunction&lt;? <span class="hljs-keyword">super</span> K, ? <span class="hljs-keyword">super</span> V, ? extends V&gt; remappingFunction)</span> </span>&#123;        <span class="hljs-keyword">if</span> (remappingFunction == <span class="hljs-keyword">null</span>)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();        Node&lt;K,V&gt; e; V oldValue;        <span class="hljs-keyword">int</span> hash = hash(key);        <span class="hljs-keyword">if</span> ((e = getNode(hash, key)) != <span class="hljs-keyword">null</span> &amp;&amp;            (oldValue = e.value) != <span class="hljs-keyword">null</span>) &#123;            V v = remappingFunction.apply(key, oldValue);            <span class="hljs-keyword">if</span> (v != <span class="hljs-keyword">null</span>) &#123;                e.value = v;                afterNodeAccess(e);                <span class="hljs-keyword">return</span> v;            &#125;            <span class="hljs-keyword">else</span>                removeNode(hash, key, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">compute</span><span class="hljs-params">(K key,</span></span><span class="hljs-function"><span class="hljs-params">                     BiFunction&lt;? <span class="hljs-keyword">super</span> K, ? <span class="hljs-keyword">super</span> V, ? extends V&gt; remappingFunction)</span> </span>&#123;        <span class="hljs-keyword">if</span> (remappingFunction == <span class="hljs-keyword">null</span>)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();        <span class="hljs-keyword">int</span> hash = hash(key);        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; <span class="hljs-keyword">int</span> n, i;        <span class="hljs-keyword">int</span> binCount = <span class="hljs-number">0</span>;        TreeNode&lt;K,V&gt; t = <span class="hljs-keyword">null</span>;        Node&lt;K,V&gt; old = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">if</span> (size &gt; threshold || (tab = table) == <span class="hljs-keyword">null</span> ||            (n = tab.length) == <span class="hljs-number">0</span>)            n = (tab = resize()).length;        <span class="hljs-keyword">if</span> ((first = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">if</span> (first <span class="hljs-keyword">instanceof</span> TreeNode)                old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);            <span class="hljs-keyword">else</span> &#123;                Node&lt;K,V&gt; e = first; K k;                <span class="hljs-keyword">do</span> &#123;                    <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;                        ((k = e.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k)))) &#123;                        old = e;                        <span class="hljs-keyword">break</span>;                    &#125;                    ++binCount;                &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-keyword">null</span>);            &#125;        &#125;        V oldValue = (old == <span class="hljs-keyword">null</span>) ? <span class="hljs-keyword">null</span> : old.value;        V v = remappingFunction.apply(key, oldValue);        <span class="hljs-keyword">if</span> (old != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">if</span> (v != <span class="hljs-keyword">null</span>) &#123;                old.value = v;                afterNodeAccess(old);            &#125;            <span class="hljs-keyword">else</span>                removeNode(hash, key, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>);        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (v != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">if</span> (t != <span class="hljs-keyword">null</span>)                t.putTreeVal(<span class="hljs-keyword">this</span>, tab, hash, key, v);            <span class="hljs-keyword">else</span> &#123;                tab[i] = newNode(hash, key, v, first);                <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>)                    treeifyBin(tab, hash);            &#125;            ++modCount;            ++size;            afterNodeInsertion(<span class="hljs-keyword">true</span>);        &#125;        <span class="hljs-keyword">return</span> v;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">merge</span><span class="hljs-params">(K key, V value,</span></span><span class="hljs-function"><span class="hljs-params">                   BiFunction&lt;? <span class="hljs-keyword">super</span> V, ? <span class="hljs-keyword">super</span> V, ? extends V&gt; remappingFunction)</span> </span>&#123;        <span class="hljs-keyword">if</span> (value == <span class="hljs-keyword">null</span>)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();        <span class="hljs-keyword">if</span> (remappingFunction == <span class="hljs-keyword">null</span>)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();        <span class="hljs-keyword">int</span> hash = hash(key);        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; <span class="hljs-keyword">int</span> n, i;        <span class="hljs-keyword">int</span> binCount = <span class="hljs-number">0</span>;        TreeNode&lt;K,V&gt; t = <span class="hljs-keyword">null</span>;        Node&lt;K,V&gt; old = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">if</span> (size &gt; threshold || (tab = table) == <span class="hljs-keyword">null</span> ||            (n = tab.length) == <span class="hljs-number">0</span>)            n = (tab = resize()).length;        <span class="hljs-keyword">if</span> ((first = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">if</span> (first <span class="hljs-keyword">instanceof</span> TreeNode)                old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);            <span class="hljs-keyword">else</span> &#123;                Node&lt;K,V&gt; e = first; K k;                <span class="hljs-keyword">do</span> &#123;                    <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;                        ((k = e.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k)))) &#123;                        old = e;                        <span class="hljs-keyword">break</span>;                    &#125;                    ++binCount;                &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-keyword">null</span>);            &#125;        &#125;        <span class="hljs-keyword">if</span> (old != <span class="hljs-keyword">null</span>) &#123;            V v;            <span class="hljs-keyword">if</span> (old.value != <span class="hljs-keyword">null</span>)                v = remappingFunction.apply(old.value, value);            <span class="hljs-keyword">else</span>                v = value;            <span class="hljs-keyword">if</span> (v != <span class="hljs-keyword">null</span>) &#123;                old.value = v;                afterNodeAccess(old);            &#125;            <span class="hljs-keyword">else</span>                removeNode(hash, key, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>);            <span class="hljs-keyword">return</span> v;        &#125;        <span class="hljs-keyword">if</span> (value != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">if</span> (t != <span class="hljs-keyword">null</span>)                t.putTreeVal(<span class="hljs-keyword">this</span>, tab, hash, key, value);            <span class="hljs-keyword">else</span> &#123;                tab[i] = newNode(hash, key, value, first);                <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>)                    treeifyBin(tab, hash);            &#125;            ++modCount;            ++size;            afterNodeInsertion(<span class="hljs-keyword">true</span>);        &#125;        <span class="hljs-keyword">return</span> value;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">forEach</span><span class="hljs-params">(BiConsumer&lt;? <span class="hljs-keyword">super</span> K, ? <span class="hljs-keyword">super</span> V&gt; action)</span> </span>&#123;        Node&lt;K,V&gt;[] tab;        <span class="hljs-keyword">if</span> (action == <span class="hljs-keyword">null</span>)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();        <span class="hljs-keyword">if</span> (size &gt; <span class="hljs-number">0</span> &amp;&amp; (tab = table) != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">int</span> mc = modCount;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; tab.length; ++i) &#123;                <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="hljs-keyword">null</span>; e = e.next)                    action.accept(e.key, e.value);            &#125;            <span class="hljs-keyword">if</span> (modCount != mc)                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();        &#125;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">replaceAll</span><span class="hljs-params">(BiFunction&lt;? <span class="hljs-keyword">super</span> K, ? <span class="hljs-keyword">super</span> V, ? extends V&gt; function)</span> </span>&#123;        Node&lt;K,V&gt;[] tab;        <span class="hljs-keyword">if</span> (function == <span class="hljs-keyword">null</span>)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();        <span class="hljs-keyword">if</span> (size &gt; <span class="hljs-number">0</span> &amp;&amp; (tab = table) != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">int</span> mc = modCount;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; tab.length; ++i) &#123;                <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="hljs-keyword">null</span>; e = e.next) &#123;                    e.value = function.apply(e.key, e.value);                &#125;            &#125;            <span class="hljs-keyword">if</span> (modCount != mc)                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();        &#125;    &#125;    <span class="hljs-comment">/* ------------------------------------------------------------ */</span>    <span class="hljs-comment">// Cloning and serialization</span>    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Returns a shallow copy of this &lt;tt&gt;HashMap&lt;/tt&gt; instance: the keys and</span><span class="hljs-comment">     * values themselves are not cloned.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> a shallow copy of this map</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> </span>&#123;        HashMap&lt;K,V&gt; result;        <span class="hljs-keyword">try</span> &#123;            result = (HashMap&lt;K,V&gt;)<span class="hljs-keyword">super</span>.clone();        &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;            <span class="hljs-comment">// this shouldn't happen, since we are Cloneable</span>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InternalError(e);        &#125;        result.reinitialize();        result.putMapEntries(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">false</span>);        <span class="hljs-keyword">return</span> result;    &#125;    <span class="hljs-comment">// These methods are also used when serializing HashSets</span>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> <span class="hljs-title">loadFactor</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> loadFactor; &#125;    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">capacity</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> (table != <span class="hljs-keyword">null</span>) ? table.length :            (threshold &gt; <span class="hljs-number">0</span>) ? threshold :            DEFAULT_INITIAL_CAPACITY;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Save the state of the &lt;tt&gt;HashMap&lt;/tt&gt; instance to a stream (i.e.,</span><span class="hljs-comment">     * serialize it).</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@serialData</span> The &lt;i&gt;capacity&lt;/i&gt; of the HashMap (the length of the</span><span class="hljs-comment">     *             bucket array) is emitted (int), followed by the</span><span class="hljs-comment">     *             &lt;i&gt;size&lt;/i&gt; (an int, the number of key-value</span><span class="hljs-comment">     *             mappings), followed by the key (Object) and value (Object)</span><span class="hljs-comment">     *             for each key-value mapping.  The key-value mappings are</span><span class="hljs-comment">     *             emitted in no particular order.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeObject</span><span class="hljs-params">(java.io.ObjectOutputStream s)</span></span><span class="hljs-function">        <span class="hljs-keyword">throws</span> IOException </span>&#123;        <span class="hljs-keyword">int</span> buckets = capacity();        <span class="hljs-comment">// Write out the threshold, loadfactor, and any hidden stuff</span>        s.defaultWriteObject();        s.writeInt(buckets);        s.writeInt(size);        internalWriteEntries(s);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Reconstitutes this map from a stream (that is, deserializes it).</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> s the stream</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> ClassNotFoundException if the class of a serialized object</span><span class="hljs-comment">     *         could not be found</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException if an I/O error occurs</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readObject</span><span class="hljs-params">(java.io.ObjectInputStream s)</span></span><span class="hljs-function">        <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException </span>&#123;        <span class="hljs-comment">// Read in the threshold (ignored), loadfactor, and any hidden stuff</span>        s.defaultReadObject();        reinitialize();        <span class="hljs-keyword">if</span> (loadFactor &lt;= <span class="hljs-number">0</span> || Float.isNaN(loadFactor))            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InvalidObjectException(<span class="hljs-string">"Illegal load factor: "</span> +                                             loadFactor);        s.readInt();                <span class="hljs-comment">// Read and ignore number of buckets</span>        <span class="hljs-keyword">int</span> mappings = s.readInt(); <span class="hljs-comment">// Read number of mappings (size)</span>        <span class="hljs-keyword">if</span> (mappings &lt; <span class="hljs-number">0</span>)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InvalidObjectException(<span class="hljs-string">"Illegal mappings count: "</span> +                                             mappings);        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mappings &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// (if zero, use defaults)</span>            <span class="hljs-comment">// Size the table using given load factor only if within</span>            <span class="hljs-comment">// range of 0.25...4.0</span>            <span class="hljs-keyword">float</span> lf = Math.min(Math.max(<span class="hljs-number">0.25f</span>, loadFactor), <span class="hljs-number">4.0f</span>);            <span class="hljs-keyword">float</span> fc = (<span class="hljs-keyword">float</span>)mappings / lf + <span class="hljs-number">1.0f</span>;            <span class="hljs-keyword">int</span> cap = ((fc &lt; DEFAULT_INITIAL_CAPACITY) ?                       DEFAULT_INITIAL_CAPACITY :                       (fc &gt;= MAXIMUM_CAPACITY) ?                       MAXIMUM_CAPACITY :                       tableSizeFor((<span class="hljs-keyword">int</span>)fc));            <span class="hljs-keyword">float</span> ft = (<span class="hljs-keyword">float</span>)cap * lf;            threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ?                         (<span class="hljs-keyword">int</span>)ft : Integer.MAX_VALUE);            <span class="hljs-comment">// Check Map.Entry[].class since it's the nearest public type to</span>            <span class="hljs-comment">// what we're actually creating.</span>            SharedSecrets.getJavaOISAccess().checkArray(s, Map.Entry[]<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">cap</span>)</span>;            <span class="hljs-meta">@SuppressWarnings</span>(&#123;<span class="hljs-string">"rawtypes"</span>,<span class="hljs-string">"unchecked"</span>&#125;)            Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> Node[cap];            table = tab;            <span class="hljs-comment">// Read the keys and values, and put the mappings in the HashMap</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mappings; i++) &#123;                <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)                    K key = (K) s.readObject();                <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)                    V value = (V) s.readObject();                putVal(hash(key), key, value, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>);            &#125;        &#125;    &#125;    <span class="hljs-comment">/* ------------------------------------------------------------ */</span>    <span class="hljs-comment">// iterators</span>    <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashIterator</span> </span>&#123;        Node&lt;K,V&gt; next;        <span class="hljs-comment">// next entry to return</span>        Node&lt;K,V&gt; current;     <span class="hljs-comment">// current entry</span>        <span class="hljs-keyword">int</span> expectedModCount;  <span class="hljs-comment">// for fast-fail</span>        <span class="hljs-keyword">int</span> index;             <span class="hljs-comment">// current slot</span>        HashIterator() &#123;            expectedModCount = modCount;            Node&lt;K,V&gt;[] t = table;            current = next = <span class="hljs-keyword">null</span>;            index = <span class="hljs-number">0</span>;            <span class="hljs-keyword">if</span> (t != <span class="hljs-keyword">null</span> &amp;&amp; size &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// advance to first entry</span>                <span class="hljs-keyword">do</span> &#123;&#125; <span class="hljs-keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="hljs-keyword">null</span>);            &#125;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> next != <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-function"><span class="hljs-keyword">final</span> Node&lt;K,V&gt; <span class="hljs-title">nextNode</span><span class="hljs-params">()</span> </span>&#123;            Node&lt;K,V&gt;[] t;            Node&lt;K,V&gt; e = next;            <span class="hljs-keyword">if</span> (modCount != expectedModCount)                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();            <span class="hljs-keyword">if</span> (e == <span class="hljs-keyword">null</span>)                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchElementException();            <span class="hljs-keyword">if</span> ((next = (current = e).next) == <span class="hljs-keyword">null</span> &amp;&amp; (t = table) != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">do</span> &#123;&#125; <span class="hljs-keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="hljs-keyword">null</span>);            &#125;            <span class="hljs-keyword">return</span> e;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123;            Node&lt;K,V&gt; p = current;            <span class="hljs-keyword">if</span> (p == <span class="hljs-keyword">null</span>)                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException();            <span class="hljs-keyword">if</span> (modCount != expectedModCount)                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();            current = <span class="hljs-keyword">null</span>;            K key = p.key;            removeNode(hash(key), key, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>);            expectedModCount = modCount;        &#125;    &#125;    <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KeyIterator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HashIterator</span></span><span class="hljs-class">        <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterator</span>&lt;<span class="hljs-title">K</span>&gt; </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> K <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> nextNode().key; &#125;    &#125;    <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ValueIterator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HashIterator</span></span><span class="hljs-class">        <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterator</span>&lt;<span class="hljs-title">V</span>&gt; </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> nextNode().value; &#125;    &#125;    <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EntryIterator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HashIterator</span></span><span class="hljs-class">        <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterator</span>&lt;<span class="hljs-title">Map</span>.<span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;&gt; </span>&#123;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Map.<span class="hljs-function">Entry&lt;K,V&gt; <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> nextNode(); &#125;    &#125;    <span class="hljs-comment">/* ------------------------------------------------------------ */</span>    <span class="hljs-comment">// spliterators</span>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashMapSpliterator</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;        <span class="hljs-keyword">final</span> HashMap&lt;K,V&gt; map;        Node&lt;K,V&gt; current;          <span class="hljs-comment">// current node</span>        <span class="hljs-keyword">int</span> index;                  <span class="hljs-comment">// current index, modified on advance/split</span>        <span class="hljs-keyword">int</span> fence;                  <span class="hljs-comment">// one past last index</span>        <span class="hljs-keyword">int</span> est;                    <span class="hljs-comment">// size estimate</span>        <span class="hljs-keyword">int</span> expectedModCount;       <span class="hljs-comment">// for comodification checks</span>        HashMapSpliterator(HashMap&lt;K,V&gt; m, <span class="hljs-keyword">int</span> origin,                           <span class="hljs-keyword">int</span> fence, <span class="hljs-keyword">int</span> est,                           <span class="hljs-keyword">int</span> expectedModCount) &#123;            <span class="hljs-keyword">this</span>.map = m;            <span class="hljs-keyword">this</span>.index = origin;            <span class="hljs-keyword">this</span>.fence = fence;            <span class="hljs-keyword">this</span>.est = est;            <span class="hljs-keyword">this</span>.expectedModCount = expectedModCount;        &#125;        <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getFence</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// initialize fence and size on first use</span>            <span class="hljs-keyword">int</span> hi;            <span class="hljs-keyword">if</span> ((hi = fence) &lt; <span class="hljs-number">0</span>) &#123;                HashMap&lt;K,V&gt; m = map;                est = m.size;                expectedModCount = m.modCount;                Node&lt;K,V&gt;[] tab = m.table;                hi = fence = (tab == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : tab.length;            &#125;            <span class="hljs-keyword">return</span> hi;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> <span class="hljs-title">estimateSize</span><span class="hljs-params">()</span> </span>&#123;            getFence(); <span class="hljs-comment">// force init</span>            <span class="hljs-keyword">return</span> (<span class="hljs-keyword">long</span>) est;        &#125;    &#125;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KeySpliterator</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;</span><span class="hljs-class">        <span class="hljs-keyword">extends</span> <span class="hljs-title">HashMapSpliterator</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;</span><span class="hljs-class">        <span class="hljs-keyword">implements</span> <span class="hljs-title">Spliterator</span>&lt;<span class="hljs-title">K</span>&gt; </span>&#123;        KeySpliterator(HashMap&lt;K,V&gt; m, <span class="hljs-keyword">int</span> origin, <span class="hljs-keyword">int</span> fence, <span class="hljs-keyword">int</span> est,                       <span class="hljs-keyword">int</span> expectedModCount) &#123;            <span class="hljs-keyword">super</span>(m, origin, fence, est, expectedModCount);        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> KeySpliterator&lt;K,V&gt; <span class="hljs-title">trySplit</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">int</span> hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; <span class="hljs-number">1</span>;            <span class="hljs-keyword">return</span> (lo &gt;= mid || current != <span class="hljs-keyword">null</span>) ? <span class="hljs-keyword">null</span> :                <span class="hljs-keyword">new</span> KeySpliterator&lt;&gt;(map, lo, index = mid, est &gt;&gt;&gt;= <span class="hljs-number">1</span>,                                        expectedModCount);        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">forEachRemaining</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-keyword">super</span> K&gt; action)</span> </span>&#123;            <span class="hljs-keyword">int</span> i, hi, mc;            <span class="hljs-keyword">if</span> (action == <span class="hljs-keyword">null</span>)                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();            HashMap&lt;K,V&gt; m = map;            Node&lt;K,V&gt;[] tab = m.table;            <span class="hljs-keyword">if</span> ((hi = fence) &lt; <span class="hljs-number">0</span>) &#123;                mc = expectedModCount = m.modCount;                hi = fence = (tab == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : tab.length;            &#125;            <span class="hljs-keyword">else</span>                mc = expectedModCount;            <span class="hljs-keyword">if</span> (tab != <span class="hljs-keyword">null</span> &amp;&amp; tab.length &gt;= hi &amp;&amp;                (i = index) &gt;= <span class="hljs-number">0</span> &amp;&amp; (i &lt; (index = hi) || current != <span class="hljs-keyword">null</span>)) &#123;                Node&lt;K,V&gt; p = current;                current = <span class="hljs-keyword">null</span>;                <span class="hljs-keyword">do</span> &#123;                    <span class="hljs-keyword">if</span> (p == <span class="hljs-keyword">null</span>)                        p = tab[i++];                    <span class="hljs-keyword">else</span> &#123;                        action.accept(p.key);                        p = p.next;                    &#125;                &#125; <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span> || i &lt; hi);                <span class="hljs-keyword">if</span> (m.modCount != mc)                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();            &#125;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAdvance</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-keyword">super</span> K&gt; action)</span> </span>&#123;            <span class="hljs-keyword">int</span> hi;            <span class="hljs-keyword">if</span> (action == <span class="hljs-keyword">null</span>)                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();            Node&lt;K,V&gt;[] tab = map.table;            <span class="hljs-keyword">if</span> (tab != <span class="hljs-keyword">null</span> &amp;&amp; tab.length &gt;= (hi = getFence()) &amp;&amp; index &gt;= <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">while</span> (current != <span class="hljs-keyword">null</span> || index &lt; hi) &#123;                    <span class="hljs-keyword">if</span> (current == <span class="hljs-keyword">null</span>)                        current = tab[index++];                    <span class="hljs-keyword">else</span> &#123;                        K k = current.key;                        current = current.next;                        action.accept(k);                        <span class="hljs-keyword">if</span> (map.modCount != expectedModCount)                            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;                    &#125;                &#125;            &#125;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">characteristics</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> (fence &lt; <span class="hljs-number">0</span> || est == map.size ? Spliterator.SIZED : <span class="hljs-number">0</span>) |                Spliterator.DISTINCT;        &#125;    &#125;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ValueSpliterator</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;</span><span class="hljs-class">        <span class="hljs-keyword">extends</span> <span class="hljs-title">HashMapSpliterator</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;</span><span class="hljs-class">        <span class="hljs-keyword">implements</span> <span class="hljs-title">Spliterator</span>&lt;<span class="hljs-title">V</span>&gt; </span>&#123;        ValueSpliterator(HashMap&lt;K,V&gt; m, <span class="hljs-keyword">int</span> origin, <span class="hljs-keyword">int</span> fence, <span class="hljs-keyword">int</span> est,                         <span class="hljs-keyword">int</span> expectedModCount) &#123;            <span class="hljs-keyword">super</span>(m, origin, fence, est, expectedModCount);        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> ValueSpliterator&lt;K,V&gt; <span class="hljs-title">trySplit</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">int</span> hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; <span class="hljs-number">1</span>;            <span class="hljs-keyword">return</span> (lo &gt;= mid || current != <span class="hljs-keyword">null</span>) ? <span class="hljs-keyword">null</span> :                <span class="hljs-keyword">new</span> ValueSpliterator&lt;&gt;(map, lo, index = mid, est &gt;&gt;&gt;= <span class="hljs-number">1</span>,                                          expectedModCount);        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">forEachRemaining</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-keyword">super</span> V&gt; action)</span> </span>&#123;            <span class="hljs-keyword">int</span> i, hi, mc;            <span class="hljs-keyword">if</span> (action == <span class="hljs-keyword">null</span>)                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();            HashMap&lt;K,V&gt; m = map;            Node&lt;K,V&gt;[] tab = m.table;            <span class="hljs-keyword">if</span> ((hi = fence) &lt; <span class="hljs-number">0</span>) &#123;                mc = expectedModCount = m.modCount;                hi = fence = (tab == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : tab.length;            &#125;            <span class="hljs-keyword">else</span>                mc = expectedModCount;            <span class="hljs-keyword">if</span> (tab != <span class="hljs-keyword">null</span> &amp;&amp; tab.length &gt;= hi &amp;&amp;                (i = index) &gt;= <span class="hljs-number">0</span> &amp;&amp; (i &lt; (index = hi) || current != <span class="hljs-keyword">null</span>)) &#123;                Node&lt;K,V&gt; p = current;                current = <span class="hljs-keyword">null</span>;                <span class="hljs-keyword">do</span> &#123;                    <span class="hljs-keyword">if</span> (p == <span class="hljs-keyword">null</span>)                        p = tab[i++];                    <span class="hljs-keyword">else</span> &#123;                        action.accept(p.value);                        p = p.next;                    &#125;                &#125; <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span> || i &lt; hi);                <span class="hljs-keyword">if</span> (m.modCount != mc)                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();            &#125;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAdvance</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-keyword">super</span> V&gt; action)</span> </span>&#123;            <span class="hljs-keyword">int</span> hi;            <span class="hljs-keyword">if</span> (action == <span class="hljs-keyword">null</span>)                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();            Node&lt;K,V&gt;[] tab = map.table;            <span class="hljs-keyword">if</span> (tab != <span class="hljs-keyword">null</span> &amp;&amp; tab.length &gt;= (hi = getFence()) &amp;&amp; index &gt;= <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">while</span> (current != <span class="hljs-keyword">null</span> || index &lt; hi) &#123;                    <span class="hljs-keyword">if</span> (current == <span class="hljs-keyword">null</span>)                        current = tab[index++];                    <span class="hljs-keyword">else</span> &#123;                        V v = current.value;                        current = current.next;                        action.accept(v);                        <span class="hljs-keyword">if</span> (map.modCount != expectedModCount)                            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;                    &#125;                &#125;            &#125;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">characteristics</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> (fence &lt; <span class="hljs-number">0</span> || est == map.size ? Spliterator.SIZED : <span class="hljs-number">0</span>);        &#125;    &#125;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EntrySpliterator</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;</span><span class="hljs-class">        <span class="hljs-keyword">extends</span> <span class="hljs-title">HashMapSpliterator</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;</span><span class="hljs-class">        <span class="hljs-keyword">implements</span> <span class="hljs-title">Spliterator</span>&lt;<span class="hljs-title">Map</span>.<span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;&gt; </span>&#123;        EntrySpliterator(HashMap&lt;K,V&gt; m, <span class="hljs-keyword">int</span> origin, <span class="hljs-keyword">int</span> fence, <span class="hljs-keyword">int</span> est,                         <span class="hljs-keyword">int</span> expectedModCount) &#123;            <span class="hljs-keyword">super</span>(m, origin, fence, est, expectedModCount);        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> EntrySpliterator&lt;K,V&gt; <span class="hljs-title">trySplit</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">int</span> hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; <span class="hljs-number">1</span>;            <span class="hljs-keyword">return</span> (lo &gt;= mid || current != <span class="hljs-keyword">null</span>) ? <span class="hljs-keyword">null</span> :                <span class="hljs-keyword">new</span> EntrySpliterator&lt;&gt;(map, lo, index = mid, est &gt;&gt;&gt;= <span class="hljs-number">1</span>,                                          expectedModCount);        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">forEachRemaining</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-keyword">super</span> Map.Entry&lt;K,V&gt;&gt; action)</span> </span>&#123;            <span class="hljs-keyword">int</span> i, hi, mc;            <span class="hljs-keyword">if</span> (action == <span class="hljs-keyword">null</span>)                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();            HashMap&lt;K,V&gt; m = map;            Node&lt;K,V&gt;[] tab = m.table;            <span class="hljs-keyword">if</span> ((hi = fence) &lt; <span class="hljs-number">0</span>) &#123;                mc = expectedModCount = m.modCount;                hi = fence = (tab == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : tab.length;            &#125;            <span class="hljs-keyword">else</span>                mc = expectedModCount;            <span class="hljs-keyword">if</span> (tab != <span class="hljs-keyword">null</span> &amp;&amp; tab.length &gt;= hi &amp;&amp;                (i = index) &gt;= <span class="hljs-number">0</span> &amp;&amp; (i &lt; (index = hi) || current != <span class="hljs-keyword">null</span>)) &#123;                Node&lt;K,V&gt; p = current;                current = <span class="hljs-keyword">null</span>;                <span class="hljs-keyword">do</span> &#123;                    <span class="hljs-keyword">if</span> (p == <span class="hljs-keyword">null</span>)                        p = tab[i++];                    <span class="hljs-keyword">else</span> &#123;                        action.accept(p);                        p = p.next;                    &#125;                &#125; <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span> || i &lt; hi);                <span class="hljs-keyword">if</span> (m.modCount != mc)                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();            &#125;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAdvance</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-keyword">super</span> Map.Entry&lt;K,V&gt;&gt; action)</span> </span>&#123;            <span class="hljs-keyword">int</span> hi;            <span class="hljs-keyword">if</span> (action == <span class="hljs-keyword">null</span>)                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();            Node&lt;K,V&gt;[] tab = map.table;            <span class="hljs-keyword">if</span> (tab != <span class="hljs-keyword">null</span> &amp;&amp; tab.length &gt;= (hi = getFence()) &amp;&amp; index &gt;= <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">while</span> (current != <span class="hljs-keyword">null</span> || index &lt; hi) &#123;                    <span class="hljs-keyword">if</span> (current == <span class="hljs-keyword">null</span>)                        current = tab[index++];                    <span class="hljs-keyword">else</span> &#123;                        Node&lt;K,V&gt; e = current;                        current = current.next;                        action.accept(e);                        <span class="hljs-keyword">if</span> (map.modCount != expectedModCount)                            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;                    &#125;                &#125;            &#125;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">characteristics</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> (fence &lt; <span class="hljs-number">0</span> || est == map.size ? Spliterator.SIZED : <span class="hljs-number">0</span>) |                Spliterator.DISTINCT;        &#125;    &#125;    <span class="hljs-comment">/* ------------------------------------------------------------ */</span>    <span class="hljs-comment">// LinkedHashMap support</span>    <span class="hljs-comment">/*</span><span class="hljs-comment">     * The following package-protected methods are designed to be</span><span class="hljs-comment">     * overridden by LinkedHashMap, but not by any other subclass.</span><span class="hljs-comment">     * Nearly all other internal methods are also package-protected</span><span class="hljs-comment">     * but are declared final, so can be used by LinkedHashMap, view</span><span class="hljs-comment">     * classes, and HashSet.</span><span class="hljs-comment">     */</span>    <span class="hljs-comment">// Create a regular (non-tree) node</span>    <span class="hljs-function">Node&lt;K,V&gt; <span class="hljs-title">newNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Node&lt;&gt;(hash, key, value, next);    &#125;    <span class="hljs-comment">// For conversion from TreeNodes to plain nodes</span>    <span class="hljs-function">Node&lt;K,V&gt; <span class="hljs-title">replacementNode</span><span class="hljs-params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Node&lt;&gt;(p.hash, p.key, p.value, next);    &#125;    <span class="hljs-comment">// Create a tree bin node</span>    <span class="hljs-function">TreeNode&lt;K,V&gt; <span class="hljs-title">newTreeNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TreeNode&lt;&gt;(hash, key, value, next);    &#125;    <span class="hljs-comment">// For treeifyBin</span>    <span class="hljs-function">TreeNode&lt;K,V&gt; <span class="hljs-title">replacementTreeNode</span><span class="hljs-params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TreeNode&lt;&gt;(p.hash, p.key, p.value, next);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Reset to initial default state.  Called by clone and readObject.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reinitialize</span><span class="hljs-params">()</span> </span>&#123;        table = <span class="hljs-keyword">null</span>;        entrySet = <span class="hljs-keyword">null</span>;        keySet = <span class="hljs-keyword">null</span>;        values = <span class="hljs-keyword">null</span>;        modCount = <span class="hljs-number">0</span>;        threshold = <span class="hljs-number">0</span>;        size = <span class="hljs-number">0</span>;    &#125;    <span class="hljs-comment">// Callbacks to allow LinkedHashMap post-actions</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">afterNodeAccess</span><span class="hljs-params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">afterNodeInsertion</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> evict)</span> </span>&#123; &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">afterNodeRemoval</span><span class="hljs-params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;    <span class="hljs-comment">// Called only from writeObject, to ensure compatible ordering.</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">internalWriteEntries</span><span class="hljs-params">(java.io.ObjectOutputStream s)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        Node&lt;K,V&gt;[] tab;        <span class="hljs-keyword">if</span> (size &gt; <span class="hljs-number">0</span> &amp;&amp; (tab = table) != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; tab.length; ++i) &#123;                <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="hljs-keyword">null</span>; e = e.next) &#123;                    s.writeObject(e.key);                    s.writeObject(e.value);                &#125;            &#125;        &#125;    &#125;    <span class="hljs-comment">/* ------------------------------------------------------------ */</span>    <span class="hljs-comment">// Tree bins</span>    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Entry for Tree bins. Extends LinkedHashMap.Entry (which in turn</span><span class="hljs-comment">     * extends Node) so can be used as extension of either regular or</span><span class="hljs-comment">     * linked node.</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">LinkedHashMap</span>.<span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;        TreeNode&lt;K,V&gt; parent;  <span class="hljs-comment">// red-black tree links</span>        TreeNode&lt;K,V&gt; left;        TreeNode&lt;K,V&gt; right;        TreeNode&lt;K,V&gt; prev;    <span class="hljs-comment">// needed to unlink next upon deletion</span>        <span class="hljs-keyword">boolean</span> red;        TreeNode(<span class="hljs-keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;            <span class="hljs-keyword">super</span>(hash, key, val, next);        &#125;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * Returns root of tree containing this node.</span><span class="hljs-comment">         */</span>        <span class="hljs-function"><span class="hljs-keyword">final</span> TreeNode&lt;K,V&gt; <span class="hljs-title">root</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">for</span> (TreeNode&lt;K,V&gt; r = <span class="hljs-keyword">this</span>, p;;) &#123;                <span class="hljs-keyword">if</span> ((p = r.parent) == <span class="hljs-keyword">null</span>)                    <span class="hljs-keyword">return</span> r;                r = p;            &#125;        &#125;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * Ensures that the given root is the first node of its bin.</span><span class="hljs-comment">         */</span>        <span class="hljs-keyword">static</span> &lt;K,V&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">moveRootToFront</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, TreeNode&lt;K,V&gt; root)</span> </span>&#123;            <span class="hljs-keyword">int</span> n;            <span class="hljs-keyword">if</span> (root != <span class="hljs-keyword">null</span> &amp;&amp; tab != <span class="hljs-keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">int</span> index = (n - <span class="hljs-number">1</span>) &amp; root.hash;                TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index];                <span class="hljs-keyword">if</span> (root != first) &#123;                    Node&lt;K,V&gt; rn;                    tab[index] = root;                    TreeNode&lt;K,V&gt; rp = root.prev;                    <span class="hljs-keyword">if</span> ((rn = root.next) != <span class="hljs-keyword">null</span>)                        ((TreeNode&lt;K,V&gt;)rn).prev = rp;                    <span class="hljs-keyword">if</span> (rp != <span class="hljs-keyword">null</span>)                        rp.next = rn;                    <span class="hljs-keyword">if</span> (first != <span class="hljs-keyword">null</span>)                        first.prev = root;                    root.next = first;                    root.prev = <span class="hljs-keyword">null</span>;                &#125;                <span class="hljs-function"><span class="hljs-keyword">assert</span> <span class="hljs-title">checkInvariants</span><span class="hljs-params">(root)</span></span>;            &#125;        &#125;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * Finds the node starting at root p with the given hash and key.</span><span class="hljs-comment">         * The kc argument caches comparableClassFor(key) upon first use</span><span class="hljs-comment">         * comparing keys.</span><span class="hljs-comment">         */</span>        <span class="hljs-function"><span class="hljs-keyword">final</span> TreeNode&lt;K,V&gt; <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> h, Object k, Class&lt;?&gt; kc)</span> </span>&#123;            TreeNode&lt;K,V&gt; p = <span class="hljs-keyword">this</span>;            <span class="hljs-keyword">do</span> &#123;                <span class="hljs-keyword">int</span> ph, dir; K pk;                TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q;                <span class="hljs-keyword">if</span> ((ph = p.hash) &gt; h)                    p = pl;                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ph &lt; h)                    p = pr;                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((pk = p.key) == k || (k != <span class="hljs-keyword">null</span> &amp;&amp; k.equals(pk)))                    <span class="hljs-keyword">return</span> p;                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pl == <span class="hljs-keyword">null</span>)                    p = pr;                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pr == <span class="hljs-keyword">null</span>)                    p = pl;                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((kc != <span class="hljs-keyword">null</span> ||                          (kc = comparableClassFor(k)) != <span class="hljs-keyword">null</span>) &amp;&amp;                         (dir = compareComparables(kc, k, pk)) != <span class="hljs-number">0</span>)                    p = (dir &lt; <span class="hljs-number">0</span>) ? pl : pr;                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((q = pr.find(h, k, kc)) != <span class="hljs-keyword">null</span>)                    <span class="hljs-keyword">return</span> q;                <span class="hljs-keyword">else</span>                    p = pl;            &#125; <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span>);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * Calls find for root node.</span><span class="hljs-comment">         */</span>        <span class="hljs-function"><span class="hljs-keyword">final</span> TreeNode&lt;K,V&gt; <span class="hljs-title">getTreeNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> h, Object k)</span> </span>&#123;            <span class="hljs-keyword">return</span> ((parent != <span class="hljs-keyword">null</span>) ? root() : <span class="hljs-keyword">this</span>).find(h, k, <span class="hljs-keyword">null</span>);        &#125;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * Tie-breaking utility for ordering insertions when equal</span><span class="hljs-comment">         * hashCodes and non-comparable. We don't require a total</span><span class="hljs-comment">         * order, just a consistent insertion rule to maintain</span><span class="hljs-comment">         * equivalence across rebalancings. Tie-breaking further than</span><span class="hljs-comment">         * necessary simplifies testing a bit.</span><span class="hljs-comment">         */</span>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">tieBreakOrder</span><span class="hljs-params">(Object a, Object b)</span> </span>&#123;            <span class="hljs-keyword">int</span> d;            <span class="hljs-keyword">if</span> (a == <span class="hljs-keyword">null</span> || b == <span class="hljs-keyword">null</span> ||                (d = a.getClass().getName().                 compareTo(b.getClass().getName())) == <span class="hljs-number">0</span>)                d = (System.identityHashCode(a) &lt;= System.identityHashCode(b) ?                     -<span class="hljs-number">1</span> : <span class="hljs-number">1</span>);            <span class="hljs-keyword">return</span> d;        &#125;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * Forms tree of the nodes linked from this node.</span><span class="hljs-comment">         */</span>        <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">treeify</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab)</span> </span>&#123;            TreeNode&lt;K,V&gt; root = <span class="hljs-keyword">null</span>;            <span class="hljs-keyword">for</span> (TreeNode&lt;K,V&gt; x = <span class="hljs-keyword">this</span>, next; x != <span class="hljs-keyword">null</span>; x = next) &#123;                next = (TreeNode&lt;K,V&gt;)x.next;                x.left = x.right = <span class="hljs-keyword">null</span>;                <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;                    x.parent = <span class="hljs-keyword">null</span>;                    x.red = <span class="hljs-keyword">false</span>;                    root = x;                &#125;                <span class="hljs-keyword">else</span> &#123;                    K k = x.key;                    <span class="hljs-keyword">int</span> h = x.hash;                    Class&lt;?&gt; kc = <span class="hljs-keyword">null</span>;                    <span class="hljs-keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;                        <span class="hljs-keyword">int</span> dir, ph;                        K pk = p.key;                        <span class="hljs-keyword">if</span> ((ph = p.hash) &gt; h)                            dir = -<span class="hljs-number">1</span>;                        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ph &lt; h)                            dir = <span class="hljs-number">1</span>;                        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((kc == <span class="hljs-keyword">null</span> &amp;&amp;                                  (kc = comparableClassFor(k)) == <span class="hljs-keyword">null</span>) ||                                 (dir = compareComparables(kc, k, pk)) == <span class="hljs-number">0</span>)                            dir = tieBreakOrder(k, pk);                        TreeNode&lt;K,V&gt; xp = p;                        <span class="hljs-keyword">if</span> ((p = (dir &lt;= <span class="hljs-number">0</span>) ? p.left : p.right) == <span class="hljs-keyword">null</span>) &#123;                            x.parent = xp;                            <span class="hljs-keyword">if</span> (dir &lt;= <span class="hljs-number">0</span>)                                xp.left = x;                            <span class="hljs-keyword">else</span>                                xp.right = x;                            root = balanceInsertion(root, x);                            <span class="hljs-keyword">break</span>;                        &#125;                    &#125;                &#125;            &#125;            moveRootToFront(tab, root);        &#125;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * Returns a list of non-TreeNodes replacing those linked from</span><span class="hljs-comment">         * this node.</span><span class="hljs-comment">         */</span>        <span class="hljs-function"><span class="hljs-keyword">final</span> Node&lt;K,V&gt; <span class="hljs-title">untreeify</span><span class="hljs-params">(HashMap&lt;K,V&gt; map)</span> </span>&#123;            Node&lt;K,V&gt; hd = <span class="hljs-keyword">null</span>, tl = <span class="hljs-keyword">null</span>;            <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; q = <span class="hljs-keyword">this</span>; q != <span class="hljs-keyword">null</span>; q = q.next) &#123;                Node&lt;K,V&gt; p = map.replacementNode(q, <span class="hljs-keyword">null</span>);                <span class="hljs-keyword">if</span> (tl == <span class="hljs-keyword">null</span>)                    hd = p;                <span class="hljs-keyword">else</span>                    tl.next = p;                tl = p;            &#125;            <span class="hljs-keyword">return</span> hd;        &#125;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * Tree version of putVal.</span><span class="hljs-comment">         */</span>        <span class="hljs-function"><span class="hljs-keyword">final</span> TreeNode&lt;K,V&gt; <span class="hljs-title">putTreeVal</span><span class="hljs-params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span><span class="hljs-function"><span class="hljs-params">                                       <span class="hljs-keyword">int</span> h, K k, V v)</span> </span>&#123;            Class&lt;?&gt; kc = <span class="hljs-keyword">null</span>;            <span class="hljs-keyword">boolean</span> searched = <span class="hljs-keyword">false</span>;            TreeNode&lt;K,V&gt; root = (parent != <span class="hljs-keyword">null</span>) ? root() : <span class="hljs-keyword">this</span>;            <span class="hljs-keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;                <span class="hljs-keyword">int</span> dir, ph; K pk;                <span class="hljs-keyword">if</span> ((ph = p.hash) &gt; h)                    dir = -<span class="hljs-number">1</span>;                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ph &lt; h)                    dir = <span class="hljs-number">1</span>;                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((pk = p.key) == k || (k != <span class="hljs-keyword">null</span> &amp;&amp; k.equals(pk)))                    <span class="hljs-keyword">return</span> p;                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((kc == <span class="hljs-keyword">null</span> &amp;&amp;                          (kc = comparableClassFor(k)) == <span class="hljs-keyword">null</span>) ||                         (dir = compareComparables(kc, k, pk)) == <span class="hljs-number">0</span>) &#123;                    <span class="hljs-keyword">if</span> (!searched) &#123;                        TreeNode&lt;K,V&gt; q, ch;                        searched = <span class="hljs-keyword">true</span>;                        <span class="hljs-keyword">if</span> (((ch = p.left) != <span class="hljs-keyword">null</span> &amp;&amp;                             (q = ch.find(h, k, kc)) != <span class="hljs-keyword">null</span>) ||                            ((ch = p.right) != <span class="hljs-keyword">null</span> &amp;&amp;                             (q = ch.find(h, k, kc)) != <span class="hljs-keyword">null</span>))                            <span class="hljs-keyword">return</span> q;                    &#125;                    dir = tieBreakOrder(k, pk);                &#125;                TreeNode&lt;K,V&gt; xp = p;                <span class="hljs-keyword">if</span> ((p = (dir &lt;= <span class="hljs-number">0</span>) ? p.left : p.right) == <span class="hljs-keyword">null</span>) &#123;                    Node&lt;K,V&gt; xpn = xp.next;                    TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);                    <span class="hljs-keyword">if</span> (dir &lt;= <span class="hljs-number">0</span>)                        xp.left = x;                    <span class="hljs-keyword">else</span>                        xp.right = x;                    xp.next = x;                    x.parent = x.prev = xp;                    <span class="hljs-keyword">if</span> (xpn != <span class="hljs-keyword">null</span>)                        ((TreeNode&lt;K,V&gt;)xpn).prev = x;                    moveRootToFront(tab, balanceInsertion(root, x));                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;                &#125;            &#125;        &#125;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * Removes the given node, that must be present before this call.</span><span class="hljs-comment">         * This is messier than typical red-black deletion code because we</span><span class="hljs-comment">         * cannot swap the contents of an interior node with a leaf</span><span class="hljs-comment">         * successor that is pinned by "next" pointers that are accessible</span><span class="hljs-comment">         * independently during traversal. So instead we swap the tree</span><span class="hljs-comment">         * linkages. If the current tree appears to have too few nodes,</span><span class="hljs-comment">         * the bin is converted back to a plain bin. (The test triggers</span><span class="hljs-comment">         * somewhere between 2 and 6 nodes, depending on tree structure).</span><span class="hljs-comment">         */</span>        <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeTreeNode</span><span class="hljs-params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span><span class="hljs-function"><span class="hljs-params">                                  <span class="hljs-keyword">boolean</span> movable)</span> </span>&#123;            <span class="hljs-keyword">int</span> n;            <span class="hljs-keyword">if</span> (tab == <span class="hljs-keyword">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)                <span class="hljs-keyword">return</span>;            <span class="hljs-keyword">int</span> index = (n - <span class="hljs-number">1</span>) &amp; hash;            TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index], root = first, rl;            TreeNode&lt;K,V&gt; succ = (TreeNode&lt;K,V&gt;)next, pred = prev;            <span class="hljs-keyword">if</span> (pred == <span class="hljs-keyword">null</span>)                tab[index] = first = succ;            <span class="hljs-keyword">else</span>                pred.next = succ;            <span class="hljs-keyword">if</span> (succ != <span class="hljs-keyword">null</span>)                succ.prev = pred;            <span class="hljs-keyword">if</span> (first == <span class="hljs-keyword">null</span>)                <span class="hljs-keyword">return</span>;            <span class="hljs-keyword">if</span> (root.parent != <span class="hljs-keyword">null</span>)                root = root.root();            <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>                || (movable                    &amp;&amp; (root.right == <span class="hljs-keyword">null</span>                        || (rl = root.left) == <span class="hljs-keyword">null</span>                        || rl.left == <span class="hljs-keyword">null</span>))) &#123;                tab[index] = first.untreeify(map);  <span class="hljs-comment">// too small</span>                <span class="hljs-keyword">return</span>;            &#125;            TreeNode&lt;K,V&gt; p = <span class="hljs-keyword">this</span>, pl = left, pr = right, replacement;            <span class="hljs-keyword">if</span> (pl != <span class="hljs-keyword">null</span> &amp;&amp; pr != <span class="hljs-keyword">null</span>) &#123;                TreeNode&lt;K,V&gt; s = pr, sl;                <span class="hljs-keyword">while</span> ((sl = s.left) != <span class="hljs-keyword">null</span>) <span class="hljs-comment">// find successor</span>                    s = sl;                <span class="hljs-keyword">boolean</span> c = s.red; s.red = p.red; p.red = c; <span class="hljs-comment">// swap colors</span>                TreeNode&lt;K,V&gt; sr = s.right;                TreeNode&lt;K,V&gt; pp = p.parent;                <span class="hljs-keyword">if</span> (s == pr) &#123; <span class="hljs-comment">// p was s's direct parent</span>                    p.parent = s;                    s.right = p;                &#125;                <span class="hljs-keyword">else</span> &#123;                    TreeNode&lt;K,V&gt; sp = s.parent;                    <span class="hljs-keyword">if</span> ((p.parent = sp) != <span class="hljs-keyword">null</span>) &#123;                        <span class="hljs-keyword">if</span> (s == sp.left)                            sp.left = p;                        <span class="hljs-keyword">else</span>                            sp.right = p;                    &#125;                    <span class="hljs-keyword">if</span> ((s.right = pr) != <span class="hljs-keyword">null</span>)                        pr.parent = s;                &#125;                p.left = <span class="hljs-keyword">null</span>;                <span class="hljs-keyword">if</span> ((p.right = sr) != <span class="hljs-keyword">null</span>)                    sr.parent = p;                <span class="hljs-keyword">if</span> ((s.left = pl) != <span class="hljs-keyword">null</span>)                    pl.parent = s;                <span class="hljs-keyword">if</span> ((s.parent = pp) == <span class="hljs-keyword">null</span>)                    root = s;                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p == pp.left)                    pp.left = s;                <span class="hljs-keyword">else</span>                    pp.right = s;                <span class="hljs-keyword">if</span> (sr != <span class="hljs-keyword">null</span>)                    replacement = sr;                <span class="hljs-keyword">else</span>                    replacement = p;            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pl != <span class="hljs-keyword">null</span>)                replacement = pl;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pr != <span class="hljs-keyword">null</span>)                replacement = pr;            <span class="hljs-keyword">else</span>                replacement = p;            <span class="hljs-keyword">if</span> (replacement != p) &#123;                TreeNode&lt;K,V&gt; pp = replacement.parent = p.parent;                <span class="hljs-keyword">if</span> (pp == <span class="hljs-keyword">null</span>)                    root = replacement;                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p == pp.left)                    pp.left = replacement;                <span class="hljs-keyword">else</span>                    pp.right = replacement;                p.left = p.right = p.parent = <span class="hljs-keyword">null</span>;            &#125;            TreeNode&lt;K,V&gt; r = p.red ? root : balanceDeletion(root, replacement);            <span class="hljs-keyword">if</span> (replacement == p) &#123;  <span class="hljs-comment">// detach</span>                TreeNode&lt;K,V&gt; pp = p.parent;                p.parent = <span class="hljs-keyword">null</span>;                <span class="hljs-keyword">if</span> (pp != <span class="hljs-keyword">null</span>) &#123;                    <span class="hljs-keyword">if</span> (p == pp.left)                        pp.left = <span class="hljs-keyword">null</span>;                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p == pp.right)                        pp.right = <span class="hljs-keyword">null</span>;                &#125;            &#125;            <span class="hljs-keyword">if</span> (movable)                moveRootToFront(tab, r);        &#125;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * Splits nodes in a tree bin into lower and upper tree bins,</span><span class="hljs-comment">         * or untreeifies if now too small. Called only from resize;</span><span class="hljs-comment">         * see above discussion about split bits and indices.</span><span class="hljs-comment">         *</span><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> map the map</span><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> tab the table for recording bin heads</span><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> index the index of the table being split</span><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> bit the bit of hash to split on</span><span class="hljs-comment">         */</span>        <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> bit)</span> </span>&#123;            TreeNode&lt;K,V&gt; b = <span class="hljs-keyword">this</span>;            <span class="hljs-comment">// Relink into lo and hi lists, preserving order</span>            TreeNode&lt;K,V&gt; loHead = <span class="hljs-keyword">null</span>, loTail = <span class="hljs-keyword">null</span>;            TreeNode&lt;K,V&gt; hiHead = <span class="hljs-keyword">null</span>, hiTail = <span class="hljs-keyword">null</span>;            <span class="hljs-keyword">int</span> lc = <span class="hljs-number">0</span>, hc = <span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span> (TreeNode&lt;K,V&gt; e = b, next; e != <span class="hljs-keyword">null</span>; e = next) &#123;                next = (TreeNode&lt;K,V&gt;)e.next;                e.next = <span class="hljs-keyword">null</span>;                <span class="hljs-keyword">if</span> ((e.hash &amp; bit) == <span class="hljs-number">0</span>) &#123;                    <span class="hljs-keyword">if</span> ((e.prev = loTail) == <span class="hljs-keyword">null</span>)                        loHead = e;                    <span class="hljs-keyword">else</span>                        loTail.next = e;                    loTail = e;                    ++lc;                &#125;                <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-keyword">if</span> ((e.prev = hiTail) == <span class="hljs-keyword">null</span>)                        hiHead = e;                    <span class="hljs-keyword">else</span>                        hiTail.next = e;                    hiTail = e;                    ++hc;                &#125;            &#125;            <span class="hljs-keyword">if</span> (loHead != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)                    tab[index] = loHead.untreeify(map);                <span class="hljs-keyword">else</span> &#123;                    tab[index] = loHead;                    <span class="hljs-keyword">if</span> (hiHead != <span class="hljs-keyword">null</span>) <span class="hljs-comment">// (else is already treeified)</span>                        loHead.treeify(tab);                &#125;            &#125;            <span class="hljs-keyword">if</span> (hiHead != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)                    tab[index + bit] = hiHead.untreeify(map);                <span class="hljs-keyword">else</span> &#123;                    tab[index + bit] = hiHead;                    <span class="hljs-keyword">if</span> (loHead != <span class="hljs-keyword">null</span>)                        hiHead.treeify(tab);                &#125;            &#125;        &#125;        <span class="hljs-comment">/* ------------------------------------------------------------ */</span>        <span class="hljs-comment">// Red-black tree methods, all adapted from CLR</span>        <span class="hljs-keyword">static</span> &lt;K,V&gt; <span class="hljs-function">TreeNode&lt;K,V&gt; <span class="hljs-title">rotateLeft</span><span class="hljs-params">(TreeNode&lt;K,V&gt; root,</span></span><span class="hljs-function"><span class="hljs-params">                                              TreeNode&lt;K,V&gt; p)</span> </span>&#123;            TreeNode&lt;K,V&gt; r, pp, rl;            <span class="hljs-keyword">if</span> (p != <span class="hljs-keyword">null</span> &amp;&amp; (r = p.right) != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">if</span> ((rl = p.right = r.left) != <span class="hljs-keyword">null</span>)                    rl.parent = p;                <span class="hljs-keyword">if</span> ((pp = r.parent = p.parent) == <span class="hljs-keyword">null</span>)                    (root = r).red = <span class="hljs-keyword">false</span>;                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pp.left == p)                    pp.left = r;                <span class="hljs-keyword">else</span>                    pp.right = r;                r.left = p;                p.parent = r;            &#125;            <span class="hljs-keyword">return</span> root;        &#125;        <span class="hljs-keyword">static</span> &lt;K,V&gt; <span class="hljs-function">TreeNode&lt;K,V&gt; <span class="hljs-title">rotateRight</span><span class="hljs-params">(TreeNode&lt;K,V&gt; root,</span></span><span class="hljs-function"><span class="hljs-params">                                               TreeNode&lt;K,V&gt; p)</span> </span>&#123;            TreeNode&lt;K,V&gt; l, pp, lr;            <span class="hljs-keyword">if</span> (p != <span class="hljs-keyword">null</span> &amp;&amp; (l = p.left) != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">if</span> ((lr = p.left = l.right) != <span class="hljs-keyword">null</span>)                    lr.parent = p;                <span class="hljs-keyword">if</span> ((pp = l.parent = p.parent) == <span class="hljs-keyword">null</span>)                    (root = l).red = <span class="hljs-keyword">false</span>;                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pp.right == p)                    pp.right = l;                <span class="hljs-keyword">else</span>                    pp.left = l;                l.right = p;                p.parent = l;            &#125;            <span class="hljs-keyword">return</span> root;        &#125;        <span class="hljs-keyword">static</span> &lt;K,V&gt; <span class="hljs-function">TreeNode&lt;K,V&gt; <span class="hljs-title">balanceInsertion</span><span class="hljs-params">(TreeNode&lt;K,V&gt; root,</span></span><span class="hljs-function"><span class="hljs-params">                                                    TreeNode&lt;K,V&gt; x)</span> </span>&#123;            x.red = <span class="hljs-keyword">true</span>;            <span class="hljs-keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123;                <span class="hljs-keyword">if</span> ((xp = x.parent) == <span class="hljs-keyword">null</span>) &#123;                    x.red = <span class="hljs-keyword">false</span>;                    <span class="hljs-keyword">return</span> x;                &#125;                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!xp.red || (xpp = xp.parent) == <span class="hljs-keyword">null</span>)                    <span class="hljs-keyword">return</span> root;                <span class="hljs-keyword">if</span> (xp == (xppl = xpp.left)) &#123;                    <span class="hljs-keyword">if</span> ((xppr = xpp.right) != <span class="hljs-keyword">null</span> &amp;&amp; xppr.red) &#123;                        xppr.red = <span class="hljs-keyword">false</span>;                        xp.red = <span class="hljs-keyword">false</span>;                        xpp.red = <span class="hljs-keyword">true</span>;                        x = xpp;                    &#125;                    <span class="hljs-keyword">else</span> &#123;                        <span class="hljs-keyword">if</span> (x == xp.right) &#123;                            root = rotateLeft(root, x = xp);                            xpp = (xp = x.parent) == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : xp.parent;                        &#125;                        <span class="hljs-keyword">if</span> (xp != <span class="hljs-keyword">null</span>) &#123;                            xp.red = <span class="hljs-keyword">false</span>;                            <span class="hljs-keyword">if</span> (xpp != <span class="hljs-keyword">null</span>) &#123;                                xpp.red = <span class="hljs-keyword">true</span>;                                root = rotateRight(root, xpp);                            &#125;                        &#125;                    &#125;                &#125;                <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-keyword">if</span> (xppl != <span class="hljs-keyword">null</span> &amp;&amp; xppl.red) &#123;                        xppl.red = <span class="hljs-keyword">false</span>;                        xp.red = <span class="hljs-keyword">false</span>;                        xpp.red = <span class="hljs-keyword">true</span>;                        x = xpp;                    &#125;                    <span class="hljs-keyword">else</span> &#123;                        <span class="hljs-keyword">if</span> (x == xp.left) &#123;                            root = rotateRight(root, x = xp);                            xpp = (xp = x.parent) == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : xp.parent;                        &#125;                        <span class="hljs-keyword">if</span> (xp != <span class="hljs-keyword">null</span>) &#123;                            xp.red = <span class="hljs-keyword">false</span>;                            <span class="hljs-keyword">if</span> (xpp != <span class="hljs-keyword">null</span>) &#123;                                xpp.red = <span class="hljs-keyword">true</span>;                                root = rotateLeft(root, xpp);                            &#125;                        &#125;                    &#125;                &#125;            &#125;        &#125;        <span class="hljs-keyword">static</span> &lt;K,V&gt; <span class="hljs-function">TreeNode&lt;K,V&gt; <span class="hljs-title">balanceDeletion</span><span class="hljs-params">(TreeNode&lt;K,V&gt; root,</span></span><span class="hljs-function"><span class="hljs-params">                                                   TreeNode&lt;K,V&gt; x)</span> </span>&#123;            <span class="hljs-keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpl, xpr;;) &#123;                <span class="hljs-keyword">if</span> (x == <span class="hljs-keyword">null</span> || x == root)                    <span class="hljs-keyword">return</span> root;                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((xp = x.parent) == <span class="hljs-keyword">null</span>) &#123;                    x.red = <span class="hljs-keyword">false</span>;                    <span class="hljs-keyword">return</span> x;                &#125;                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x.red) &#123;                    x.red = <span class="hljs-keyword">false</span>;                    <span class="hljs-keyword">return</span> root;                &#125;                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((xpl = xp.left) == x) &#123;                    <span class="hljs-keyword">if</span> ((xpr = xp.right) != <span class="hljs-keyword">null</span> &amp;&amp; xpr.red) &#123;                        xpr.red = <span class="hljs-keyword">false</span>;                        xp.red = <span class="hljs-keyword">true</span>;                        root = rotateLeft(root, xp);                        xpr = (xp = x.parent) == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : xp.right;                    &#125;                    <span class="hljs-keyword">if</span> (xpr == <span class="hljs-keyword">null</span>)                        x = xp;                    <span class="hljs-keyword">else</span> &#123;                        TreeNode&lt;K,V&gt; sl = xpr.left, sr = xpr.right;                        <span class="hljs-keyword">if</span> ((sr == <span class="hljs-keyword">null</span> || !sr.red) &amp;&amp;                            (sl == <span class="hljs-keyword">null</span> || !sl.red)) &#123;                            xpr.red = <span class="hljs-keyword">true</span>;                            x = xp;                        &#125;                        <span class="hljs-keyword">else</span> &#123;                            <span class="hljs-keyword">if</span> (sr == <span class="hljs-keyword">null</span> || !sr.red) &#123;                                <span class="hljs-keyword">if</span> (sl != <span class="hljs-keyword">null</span>)                                    sl.red = <span class="hljs-keyword">false</span>;                                xpr.red = <span class="hljs-keyword">true</span>;                                root = rotateRight(root, xpr);                                xpr = (xp = x.parent) == <span class="hljs-keyword">null</span> ?                                    <span class="hljs-keyword">null</span> : xp.right;                            &#125;                            <span class="hljs-keyword">if</span> (xpr != <span class="hljs-keyword">null</span>) &#123;                                xpr.red = (xp == <span class="hljs-keyword">null</span>) ? <span class="hljs-keyword">false</span> : xp.red;                                <span class="hljs-keyword">if</span> ((sr = xpr.right) != <span class="hljs-keyword">null</span>)                                    sr.red = <span class="hljs-keyword">false</span>;                            &#125;                            <span class="hljs-keyword">if</span> (xp != <span class="hljs-keyword">null</span>) &#123;                                xp.red = <span class="hljs-keyword">false</span>;                                root = rotateLeft(root, xp);                            &#125;                            x = root;                        &#125;                    &#125;                &#125;                <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// symmetric</span>                    <span class="hljs-keyword">if</span> (xpl != <span class="hljs-keyword">null</span> &amp;&amp; xpl.red) &#123;                        xpl.red = <span class="hljs-keyword">false</span>;                        xp.red = <span class="hljs-keyword">true</span>;                        root = rotateRight(root, xp);                        xpl = (xp = x.parent) == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : xp.left;                    &#125;                    <span class="hljs-keyword">if</span> (xpl == <span class="hljs-keyword">null</span>)                        x = xp;                    <span class="hljs-keyword">else</span> &#123;                        TreeNode&lt;K,V&gt; sl = xpl.left, sr = xpl.right;                        <span class="hljs-keyword">if</span> ((sl == <span class="hljs-keyword">null</span> || !sl.red) &amp;&amp;                            (sr == <span class="hljs-keyword">null</span> || !sr.red)) &#123;                            xpl.red = <span class="hljs-keyword">true</span>;                            x = xp;                        &#125;                        <span class="hljs-keyword">else</span> &#123;                            <span class="hljs-keyword">if</span> (sl == <span class="hljs-keyword">null</span> || !sl.red) &#123;                                <span class="hljs-keyword">if</span> (sr != <span class="hljs-keyword">null</span>)                                    sr.red = <span class="hljs-keyword">false</span>;                                xpl.red = <span class="hljs-keyword">true</span>;                                root = rotateLeft(root, xpl);                                xpl = (xp = x.parent) == <span class="hljs-keyword">null</span> ?                                    <span class="hljs-keyword">null</span> : xp.left;                            &#125;                            <span class="hljs-keyword">if</span> (xpl != <span class="hljs-keyword">null</span>) &#123;                                xpl.red = (xp == <span class="hljs-keyword">null</span>) ? <span class="hljs-keyword">false</span> : xp.red;                                <span class="hljs-keyword">if</span> ((sl = xpl.left) != <span class="hljs-keyword">null</span>)                                    sl.red = <span class="hljs-keyword">false</span>;                            &#125;                            <span class="hljs-keyword">if</span> (xp != <span class="hljs-keyword">null</span>) &#123;                                xp.red = <span class="hljs-keyword">false</span>;                                root = rotateRight(root, xp);                            &#125;                            x = root;                        &#125;                    &#125;                &#125;            &#125;        &#125;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * Recursive invariant check</span><span class="hljs-comment">         */</span>        <span class="hljs-keyword">static</span> &lt;K,V&gt; <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">checkInvariants</span><span class="hljs-params">(TreeNode&lt;K,V&gt; t)</span> </span>&#123;            TreeNode&lt;K,V&gt; tp = t.parent, tl = t.left, tr = t.right,                tb = t.prev, tn = (TreeNode&lt;K,V&gt;)t.next;            <span class="hljs-keyword">if</span> (tb != <span class="hljs-keyword">null</span> &amp;&amp; tb.next != t)                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            <span class="hljs-keyword">if</span> (tn != <span class="hljs-keyword">null</span> &amp;&amp; tn.prev != t)                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            <span class="hljs-keyword">if</span> (tp != <span class="hljs-keyword">null</span> &amp;&amp; t != tp.left &amp;&amp; t != tp.right)                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            <span class="hljs-keyword">if</span> (tl != <span class="hljs-keyword">null</span> &amp;&amp; (tl.parent != t || tl.hash &gt; t.hash))                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            <span class="hljs-keyword">if</span> (tr != <span class="hljs-keyword">null</span> &amp;&amp; (tr.parent != t || tr.hash &lt; t.hash))                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            <span class="hljs-keyword">if</span> (t.red &amp;&amp; tl != <span class="hljs-keyword">null</span> &amp;&amp; tl.red &amp;&amp; tr != <span class="hljs-keyword">null</span> &amp;&amp; tr.red)                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            <span class="hljs-keyword">if</span> (tl != <span class="hljs-keyword">null</span> &amp;&amp; !checkInvariants(tl))                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            <span class="hljs-keyword">if</span> (tr != <span class="hljs-keyword">null</span> &amp;&amp; !checkInvariants(tr))                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/07/11/hello-world/"/>
    <url>/2020/07/11/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="hljs bash">$ hexo new <span class="hljs-string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="hljs bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="hljs bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="hljs bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
